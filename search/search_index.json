{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"Introduction to R Lesson Overview 1. Introduction General overview of R 2. R Basics In the beginning.... 3. Data prelude What is data how it works 4. Factors and Dataframes  Handling Data 5. Introduction to Bioconductor Bioinformatics Resources 6. Data wrangling and analyses with Tidyverse The Tidyverse for handling data 7. Data Visualisation Plotting 8. Producing reports with knitr Writing Reports 9. R-help More Resources"},{"location":"00-introduction/","title":"Introducing R and RStudio IDE","text":"<p>Info</p> <p>keypoints:</p> <ul> <li>R is a powerful, popular open-source scripting language</li> <li>You can customize the layout of RStudio, and use the project feature   to manage the files and packages used in your analysis</li> <li>RStudio allows you to run R in an easy-to-use interface and makes it   easy to find help</li> </ul> <p>objectives:</p> <ul> <li>Know advantages of analyzing data in R</li> <li>Know advantages of using RStudio</li> <li>Create an RStudio project, and know the benefits of working within a   project</li> <li>Be able to customize the RStudio layout</li> <li>Be able to locate and change the current working directory with   <code>getwd()</code> and <code>setwd()</code></li> <li>Compose an R script file containing comments and commands</li> <li>Understand what an R function is</li> <li>Locate help for an R function using <code>?</code>, <code>??</code>, and <code>args()</code></li> </ul>"},{"location":"00-introduction/#getting-ready-to-use-r-for-the-first-time","title":"Getting ready to use R for the first time","text":"<p>In this lesson we will take you through the very first things you need to get R working.</p>"},{"location":"00-introduction/#a-brief-history-of-r","title":"A Brief History of R","text":"<p>R has been around since 1995, and was created by Ross Ihaka and Robert Gentleman at the University of Auckland, New Zealand. R is based off the S programming language developed at Bell Labs and was developed to teach intro statistics. See this slide deck by Ross Ihaka for more info on the subject.</p>"},{"location":"00-introduction/#advantages-of-using-r","title":"Advantages of using R","text":"<p>At more than 20 years old, R is fairly mature and growing in popularity. However, programming isn't a popularity contest. Here are key advantages of analyzing data in R:</p> <ul> <li>R is open     source. This     means R is free - an advantage if you are at an institution where     you have to pay for your own MATLAB or SAS license. Open source, is     important to your colleagues in parts of the world where expensive     software in inaccessible. It also means that R is actively developed     by a community (see r-project.org),     and there are regular updates.</li> <li>R is widely used. Ok, maybe programming is a popularity contest.     Because, R is used in many areas (not just bioinformatics), you are     more likely to find help online when you need it. Chances are,     almost any error message you run into, someone else has already     experienced.</li> <li>R is powerful. R runs on multiple platforms     (Windows/MacOS/Linux). It can work with much larger datasets than     popular spreadsheet programs like Microsoft Excel, and because of     its scripting capabilities is far more reproducible. Also, there are     thousands of available software packages for science, including genomics and other areas of life science.</li> </ul> <p>Discussion: Your experience</p> <p>What has motivated you to learn R? Have you had a research question for which spreadsheet programs such as Excel have proven difficult to use, or where the size of the data set created issues? {: .discussion}</p>"},{"location":"00-introduction/#introducing-rstudio-server","title":"Introducing RStudio Server","text":"<p>In these lessons, we will be making use of a software called RStudio, an Integrated Development Environment (IDE). RStudio, like most IDEs, provides a graphical interface to R, making it more user-friendly, and providing dozens of useful features. We will introduce additional benefits of using RStudio as you cover the lessons. In this case, we are specifically using RStudio Server, a version of RStudio that can be accessed in your web browser. RStudio Server has the same features of the Desktop version of RStudio you could download as standalone software.</p> <p></p>"},{"location":"00-introduction/#create-an-rstudio-project","title":"Create an RStudio project","text":"<p>One of the first benefits we will take advantage of in RStudio is something called an RStudio Project. An RStudio project allows you to more easily:</p> <ul> <li>Save data, files, variables, packages, etc. related to a specific      analysis project</li> <li>Restart work where you left off</li> <li>Collaborate, especially if you are using version control such as     git.</li> </ul> <ol> <li> <p>To create a project, go to the File menu, and click New Project</p> <p></p> </li> <li> <p>In the window that opens select New Directory, then New     Project. For \"Directory name:\" enter dc_genomics_r. For     \"Create project as subdirectory of\", click     <code>Browse...</code> and then click     <code>Choose</code> which will select your home     directory \"~\".</p> </li> <li> <p>Finally click <code>Create Project</code>. In the     \"Files\" tab of your output pane (more about the RStudio layout in a     moment), you should see an RStudio project file,     dc_genomics_r.Rproj. All RStudio projects end with the     \".Rproj\" file extension.</p> </li> </ol> <p>Make your project more reproducible with renv</p> <p>One of the most wonderful and also frustrating aspects of working with R is managing packages. We will talk more about them, but packages (e.g.\u00a0ggplot2) are add-ons that extend what you can do with R. Unfortunately it is very common that you may run into versions of R and/or R packages that are not compatible. This may make it difficult for someone to run your R script using their version of R or a given R package, and/or make it more difficult to run their scripts on your machine. renv is an RStudio add-on that will associate your packages and project so that your work is more portable and reproducible. To turn on renv click on the <code>Tools</code> menu and select <code>Project Options</code>. Under Enviornments check off \"Use renv with this project\" and follow any installation instructions. {: .callout}</p>"},{"location":"00-introduction/#creating-your-first-r-script","title":"Creating your first R script","text":"<p>Now that we are ready to start exploring R, we will want to keep a record of the commands we are using. To do this we can create an R script:</p> <p>Click the <code>File</code> menu and select <code>New File</code> and then <code>R Script</code>. Before we go any further, save your script by clicking the save/disk icon that is in the bar above the first line in the script editor, or click the <code>File</code> menu and select <code>save</code>. In the \"Save File\" window that opens, name your file \"genomics_r_basics\". The new script genomics_r_basics.R should appear under \"files\" in the output pane. By convention, R scripts end with the file extension .R.</p>"},{"location":"00-introduction/#overview-and-customization-of-the-rstudio-layout","title":"Overview and customization of the RStudio layout","text":"<p>Here are the major windows (or panes) of the RStudio environment:</p> <p></p> <ul> <li>Source: This pane is where you will write/view R scripts. Some     outputs (such as if you view a dataset using <code>View()</code>) will appear     as a tab here.</li> <li>Console/Terminal/Jobs: This is actually where you see the     execution of commands. This is the same display you would see if you     were using R at the command line without RStudio. You can work     interactively (i.e.\u00a0enter R commands here), but for the most part we     will run a script (or lines in a script) in the source pane and     watch their execution and output here. The \"Terminal\" tab give you     access to the BASH terminal (the Linux operating system, unrelated     to R). RStudio also allows you to run jobs (analyses) in the     background. This is useful if some analysis will take a while to     run. You can see the status of those jobs in the background.</li> <li>Environment/History: Here, RStudio will show you what datasets     and objects (variables) you have created and which are defined in     memory. You can also see some properties of objects/datasets such as     their type and dimensions. The \"History\" tab contains a history of     the R commands you've executed R.</li> <li>Files/Plots/Packages/Help/Viewer: This multipurpose pane will     show you the contents of directories on your computer. You can also     use the \"Files\" tab to navigate and set the working directory. The     \"Plots\" tab will show the output of any plots generated. In     \"Packages\" you will see what packages are actively loaded, or you     can attach installed packages. \"Help\" will display help files for R     functions and packages. \"Viewer\" will allow you to view local web     content (e.g.\u00a0HTML outputs).</li> </ul> <p>Uploads and downloads in the cloud</p> <p>In the \"Files\" tab you can select a file and download it from your cloud instance (click the \"more\" button) to your local computer. Uploads are also possible. {: .callout}</p> <p>All of the panes in RStudio have configuration options. For example, you can minimize/maximize a pane, or by moving your mouse in the space between panes you can resize as needed. The most important customization options for pane layout are in the <code>View</code> menu. Other options such as font sizes, colors/themes, and more are in the <code>Tools</code> menu under <code>Global Options</code>.</p> <p>You are working with R</p> <p>Although we won't be working with R at the terminal, there are lots of reasons to. For example, once you have written an RScript, you can run it at any Linux or Windows terminal without the need to start up RStudio. We don't want you to get confused - RStudio runs R, but R is not RStudio. For more on running an R Script at the terminal see this Software Carpentry lesson.</p>"},{"location":"00-introduction/#getting-to-work-with-r-navigating-directories","title":"Getting to work with R: navigating directories","text":"<p>Now that we have covered the more aesthetic aspects of RStudio, we can get to work using some commands. We will write, execute, and save the commands we learn in our genomics_r_basics.R script that is loaded in the Source pane. First, lets see what directory we are in. To do so, type the following command into the script:</p> <p>R-project</p> <p><code>getwd()</code></p> <p>To execute this command, make sure your cursor is on the same line the command is written. Then click the <code>Run</code> button that is just above the first line of your script in the header of the Source pane.</p> <p>In the console, we expect to see the following output :</p> <p><code>[1] \"/home/dcuser/dc_genomics_r\"</code></p> <ul> <li>Notice, at the Console, you will also see the instruction you executed above the output in blue.</li> </ul> <p>Since we will be learning several commands, we may already want to keep some short notes in our script to explain the purpose of the command. Entering a <code>#</code> before any line in an R script turns that line into a comment, which R will not try to interpret as code. Edit your script to include a comment on the purpose of commands you are learning, e.g.:</p> <p>R-project</p> <p><code># this</code>ommand shows the current working directory getwd()`</p> <p>Exercise : Work interactively in R</p> <p>What happens when you try to enter the <code>getwd()</code> command in the Console pane?</p> Solution <p>You will get the same output you did as when you ran <code>getwd()</code> from  the source. You can run any command in the Console, however,  executing it from the source script will make it easier for us to  record what we have done, and ultimately run an entire script,  instead of entering commands one-by-one. {: .solution} {:  .challenge}</p> <p>For the purposes of this exercise we want you to be in the directory <code>\"/home/dcuser/R_data\"</code>. What if you weren't? You can set your home directory using the <code>setwd()</code> command. Enter this command in your script, but don't run this yet.</p> <p>R-project</p> <p><code># This</code>ets the working directory setwd()`</p> <p>You may have guessed, you need to tell the <code>setwd()</code> command what directory you want to set as your working directory. To do so, inside of the parentheses, open a set of quotes. Inside the quotes enter a <code>/</code> which is the root directory for Linux. Next, use the <code>Tab</code> key, to take advantage of RStudio's Tab-autocompletion method, to select <code>home</code>, <code>dcuser</code>, and <code>dc_genomics_r</code> directory. The path in your script should look like this:</p> <p>R-project</p> <p><code># This</code>ets the working directory setwd(\"/home/dcuser/dc_genomics_r\")`</p> <p>When you run this command, the console repeats the command, but gives you no output. Instead, you see the blank R prompt: <code>&gt;</code>. Congratulations! Although it seems small, knowing what your working directory is and being able to set your working directory is the first step to analyzing your data.</p> <p>Never use <code>setwd()</code></p> <p>Wait, what was the last 2 minutes about? Well, setting your working directory is something you need to do, you need to be very careful about using this as a step in your script. For example, what if your script is being on a computer that has a different directory structure? The top-level path in a Unix file system is root <code>/</code>, but on Windows it is likely <code>C:\\</code>. This is one of several ways you might cause a script to break because a file path is configured differently than your script anticipates. R packages like here and file.path allow you to specify file paths is a way that is more operating system independent. See Jenny Bryan's blog post for this and other R tips. {: .callout}   </p>"},{"location":"00-introduction/#using-functions-in-r-without-needing-to-master-them","title":"Using functions in R, without needing to master them","text":"<p>A function in R (or any computing language) is a short program that takes some input and returns some output. Functions may seem like an advanced topic (and they are), but you have already used at least one function in R. <code>getwd()</code> is a function! The next sections will help you understand what is happening in any R script.</p> <p>Exercise: What do these functions do?</p> <p>Try the following functions by writing them in your script. See if you can guess what they do, and make sure to add comments to your script about your assumed purpose. - <code>dir()</code> - <code>sessionInfo()</code> - <code>date()</code> - <code>Sys.time()</code></p> Solution <ul> <li><code>dir()</code> # Lists files in the working directory</li> <li><code>sessionInfo()</code> # Gives the version of R and additional info     including on attached packages</li> <li><code>date()</code> # Gives the current date</li> <li><code>Sys.time()</code> # Gives the current time</li> </ul> <p>Notice: Commands are case sensitive! </p> <p>You have hopefully noticed a pattern - an R function has three key properties: - Functions have a name (e.g.\u00a0<code>dir</code>, <code>getwd</code>); note that functions are case sensitive! - Following the name, functions have a pair of <code>()</code> - Inside the parentheses, a function may take 0 or more arguments</p> <p>An argument may be a specific input for your function and/or may modify the function's behavior. For example the function <code>round()</code> will round a number with a decimal:</p> <p>r</p> <pre><code># This will round a number to the nearest integer\nround(3.14)\n</code></pre>"},{"location":"00-introduction/#getting-help-with-function-arguments","title":"Getting help with function arguments","text":"<p>What if you wanted to round to one significant digit? <code>round()</code> can do this, but you may first need to read the help to find out how. To see the help (In R sometimes also called a \"vignette\") enter a <code>?</code> in front of the function name:</p> <p>r</p> <p><code>round()</code></p> <p>The \"Help\" tab will show you information (often, too much information). You will slowly learn how to read and make sense of help files. Checking the \"Usage\" or \"Examples\" headings is often a good place to look first. If you look under \"Arguments,\" we also see what arguments we can pass to this function to modify its behavior. You can also see a function's argument using the <code>args()</code> function:</p> <p>r</p> <p><code>args(round)</code></p> <p><code>round()</code> takes two arguments, <code>x</code>, which is the number to be rounded, and a <code>digits</code> argument. The <code>=</code> sign indicates that a default (in this case 0) is already set. Since <code>x</code> is not set, <code>round()</code> requires we provide it, in contrast to <code>digits</code> where R will use the default value 0 unless you explicitly provide a different value. We can explicitly set the digits parameter when we call the function:</p> <p>r</p> <p><code>round(3.14159, digits = 2)</code></p> <p>Or, R accepts what we call \"positional arguments\", if you pass a function arguments separated by commas, R assumes that they are in the order you saw when we used <code>args()</code>. In the case below that means that <code>x</code> is 3.14159 and digits is 2.</p> <p>r</p> <p><code>round(3.14159, 2)</code></p> <p>Finally, what if you are using <code>?</code> to get help for a function in a package not installed on your system, such as when you are running a script which has dependencies.</p> <p>r</p> <p><code>geom_point()</code></p> <p>will return an error:</p> <p>Error</p> <pre><code>Error in .helpForCall(topicExpr, parent.frame()) :\n   no methods for \u2018geom_point\u2019 and no documentation for it as a function\n</code></pre> <p>Use two question marks (i.e.\u00a0<code>??geom_point()</code>) and R will return results from a search of the documentation for packages you have installed on your computer in the \"Help\" tab. Finally, if you think there should be a function, for example a statistical test, but you aren't sure what it is called in R, or what functions may be available, use the <code>help.search()</code> function.</p> <p>Exercise: Searching for R functions</p> <p>Use <code>help.search()</code> to find R functions for the following statistical functions. Remember to put your search query in quotes inside the function's parentheses.</p> <ul> <li>Chi-Squared test</li> <li>Student t-test</li> <li>mixed linear model</li> </ul> Success <p>While your search results may return several tests, we list a few you might find: </p> <ul> <li>Chi-Squared test: <code>stats::Chisquare</code> </li> <li>Student t-test: <code>stats::t.test</code> </li> <li>mixed linear model: <code>stats::lm.glm</code></li> </ul> <p>We will discuss more on where to look for the libraries and packages that contain functions you want to use. For now, be aware that two important ones are CRAN - the main repository for R, and Bioconductor - a popular repository for bioinformatics-related R packages.</p>"},{"location":"00-introduction/#rstudio-contextual-help","title":"RStudio contextual help","text":"<p>Here is one last bonus we will mention about RStudio. It's difficult to remember all of the arguments and definitions associated with a given function. When you start typing the name of a function and hit the <code>Tab</code> key, RStudio will display functions and associated help:</p> <p></p> <p>Once you type a function, hitting the <code>Tab</code> inside the parentheses will show you the function's arguments and provide additional help for each of these arguments.</p> <p></p>"},{"location":"01-r-basics/","title":"R Basics","text":"<p>Info</p> <p>keypoints:</p> <ul> <li>Effectively using R is a journey of months or years. Still you don't   have to be an expert to use R and you can start using and analyzing   your data with with about a day's worth of training</li> <li>It is important to understand how data are organized by R in a given   object type and how the mode of that type (e.g.\u00a0numeric, character,   logical, etc.) will determine how R will operate on that data.</li> <li>Working with vectors effectively prepares you for understanding how   data are organized in R.</li> </ul> <p>objectives:</p> <ul> <li>Be able to create the most common R objects including vectors</li> <li>Understand that vectors have modes, which correspond to the type of   data they contain</li> <li>Be able to use arithmetic operators on R objects</li> <li>Be able to retrieve (subset), name, or replace, values from a vector</li> <li>Be able to use logical operators in a subsetting operation</li> <li>Understand that lists can hold data of more than one mode and can be   indexed</li> </ul> <p>questions:</p> <ul> <li>What will these lessons not cover?</li> <li>What are the basic features of the R language?</li> <li>What are the most common objects in R?</li> </ul>"},{"location":"01-r-basics/#the-fantastic-world-of-r-awaits-you-or-nobody-wants-to-learn-how-to-use-r","title":"\"The fantastic world of R awaits you\" OR \"Nobody wants to learn how to use R\"","text":"<p>Before we begin this lesson, we want you to be clear on the goal of the workshop and these lessons. We believe that every learner can achieve competency with R. You have reached competency when you find that you are able to use R to handle common analysis challenges in a reasonable amount of time (which includes time needed to look at learning materials, search for answers online, and ask colleagues for help). As you spend more time using R (there is no substitute for regular use and practice) you will find yourself gaining competency and even expertise. The more familiar you get, the more complex the analyses you will be able to carry out, with less frustration, and in less time - the fantastic world of R awaits you!</p>"},{"location":"01-r-basics/#what-these-lessons-will-not-teach-you","title":"What these lessons will not teach you","text":"<p>Nobody wants to learn how to use R. People want to learn how to use R to analyze their own research questions! Ok, maybe some folks learn R for R's sake, but these lessons assume that you want to start analyzing genomic data as soon as possible. Given this, there are many valuable pieces of information about R that we simply won't have time to cover. Hopefully, we will clear the hurdle of giving you just enough knowledge to be dangerous, which can be a high bar in R! We suggest you look into the additional learning materials in the tip box below.</p> <p>Here are some R skills we will not cover in these lessons</p> <ul> <li>How to create and work with R matrices and R lists</li> <li>How to create and work with loops and conditional statements, and     the \"apply\" family of functions (which are super useful, read more     here)</li> <li>How to do basic string manipulations (e.g.\u00a0finding patterns in text     using grep, replacing text)</li> <li>How to plot using the default R graphic tools (we will cover plot     creation, but will do so using the popular plotting package     <code>ggplot2</code>)</li> <li>How to use advanced R statistical functions</li> </ul> <p>Where to learn more</p> <p>The following are good resources for learning more about R. Some of them can be quite technical, but if you are a regular R user you may ultimately need this technical knowledge. - R for Beginners: By Emmanuel Paradis and a great starting point - The R Manuals: Maintained by the R project - R contributed documentation: Also linked to the R project; importantly there are materials available in several languages - R for Data Science: A wonderful collection by noted R educators and developers Garrett Grolemund and Hadley Wickham - Practical Data Science for Stats: Not exclusively about R usage, but a nice collection of pre-prints on data science and applications for R - Programming in R Software Carpentry lesson: There are several Software Carpentry lessons in R to choose from </p>"},{"location":"01-r-basics/#creating-objects-in-r","title":"Creating objects in R","text":"<p>Reminder</p> <p>At this point you should be coding along in the \"genomics_r_basics.R\" script we created in the last episode. Writing your commands in the script (and commenting it) will make it easier to record what you did and why. </p> <p>What might be called a variable in many languages is called an object in R.</p> <p>To create an object you need:</p> <ul> <li>a name (e.g.\u00a0'a')</li> <li>a value (e.g.\u00a0'1')</li> <li>the assignment operator ('\\&lt;-')</li> </ul> <p>In your script, \"genomics_r_basics.R\", using the R assignment operator '\\&lt;-', assign '1' to the object 'a' as shown. Remember to leave a comment in the line above (using the '#') to explain what you are doing:</p> <p>r</p> <pre><code># this line creates the object 'a' and assigns it the value '1'\n\na \\&lt;- 1\n</code></pre> <p>Next, run this line of code in your script. You can run a line of code   by hitting the <code>Run</code> button that is just above the first line of your   script in the header of the Source pane or you can use the appropriate shortcut:</p> <ul> <li>Windows execution shortcut: <code>Ctrl+Enter</code></li> <li> <p>Mac execution shortcut: <code>Cmd(\u2318)+Enter</code>   To run multiple lines of code, you can highlight all the line you wish to run   and then hit Run or use the shortcut key combo listed above.</p> <p>In the RStudio 'Console' you should see:</p> <p><pre><code>a &lt;- 1\n&gt;\n</code></pre></p> <p>The 'Console' will display lines of code run from a script and any outputs or status/warning/error messages (usually in red).</p> <p>In the 'Environment' window you will also get a table:</p> Values a 1 <p>The 'Environment' window allows you to keep track of the objects you have created in R.</p> </li> </ul> <p>Exercise: Create some objects in R</p> <p>Create the following objects; give each object an appropriate name (your best guess at what name to use is fine):</p> <ol> <li>Create an object that has the value of number of pairs of human chromosomes</li> <li>Create an object that has a value of your favorite gene name</li> <li>Create an object that has this URL as its value: \"ftp://ftp.ensemblgenomes.org/pub/bacteria/release-39/fasta/bacteria_5_collection/escherichia_coli_b_str_rel606/\"</li> <li>Create an object that has the value of the number of chromosomes in a diploid human cell</li> </ol> Solution <p>Here as some possible answers to the challenge:</p> <p>r</p> <pre><code>human_chr_number &lt;- 23\ngene_name &lt;- 'pten'\nensemble_url &lt;- 'ftp://ftp.ensemblgenomes.org/pub/bacteria/release-39/fasta/bacteria_5_collection/escherichia_coli_b_str_rel606/'\nhuman_diploid_chr_num &lt;-  2 * human_chr_number\n</code></pre>"},{"location":"01-r-basics/#naming-objects-in-r","title":"Naming objects in R","text":"<p>Here are some important details about naming objects in R</p> <ul> <li>Avoid spaces and special characters: Object names cannot contain spaces or the minus sign (<code>-</code>). You can use '_' to make names more readable. You should avoid   using special characters in your object name (e.g. ! @ # . , etc.). Also,   object names cannot begin with a number.</li> <li>Use short, easy-to-understand names: You should avoid naming your objects   using single letters (e.g. 'n', 'p', etc.). This is mostly to encourage you   to use names that would make sense to anyone reading your code (a colleague,   or even yourself a year from now). Also, avoiding excessively long names will   make your code more readable.</li> <li>Avoid commonly used names: There are several names that may already have a   definition in the R language (e.g. 'mean', 'min', 'max'). One clue that a name   already has meaning is that if you start typing a name in RStudio and it gets   a colored highlight or RStudio gives you a suggested autocompletion you have   chosen a name that has a reserved meaning.</li> <li>Use the recommended assignment operator: In R, we use '&lt;- ' as the   preferred assignment operator. '=' works too, but is most commonly used in   passing arguments to functions (more on functions later). There is a shortcut   for the R assignment operator:</li> <li>Windows execution shortcut: Alt+-</li> <li>Mac execution shortcut: Option+-</li> </ul> <p>There are a few more suggestions about naming and style you may want to learn more about as you write more R code. There are several \"style guides\" that have advice, and one to start with is the tidyverse R style guide.</p> <p>Pay attention to warnings in the script console</p> <p>If you enter a line of code in your script that contains an error, RStudio may give you an error message and underline this mistake. Sometimes these messages are easy to understand, but often the messages may need some figuring out. Paying attention to these warnings will help you avoid mistakes. In the example below, our object name has a space, which is not allowed in R. The error message does not say this directly, but R is \"not sure\" about how to assign the name to \"human_ chr_number\" when the object name we want is \"human_chr_number\".</p> <p></p>"},{"location":"01-r-basics/#reassigning-object-names-or-deleting-objects","title":"Reassigning object names or deleting objects","text":"<p>Once an object has a value, you can change that value by overwriting it. R will not give you a warning or error if you overwriting an object, which may or may not be a good thing depending on how you look at it.</p> <p>r</p> <pre><code># gene_name has the value 'pten' or whatever value you used in the challenge\n# We will now assign the new value 'tp53'\n\ngene_name &lt;- 'tp53'\n</code></pre> <p>You can also remove an object from R's memory entirely. The <code>rm()</code> function will delete the object.</p> <p>r</p> <pre><code># delete the object 'gene_name'\nrm(gene_name)\n</code></pre> <p>If you run a line of code that has only an object name, R will normally display the contents of that object. In this case, we are told the object no longer exists.</p> <p>Error</p> <pre><code>Error: object 'gene_name' not found\n</code></pre>"},{"location":"01-r-basics/#understanding-object-data-types-modes","title":"Understanding object data types (modes)","text":"<p>In R, every object has two properties:</p> <ul> <li>Length: How many distinct values are held in that object</li> <li>Mode: What is the classification (type) of that object.</li> </ul> <p>We will get to the \"length\" property later in the lesson. The \"mode\" property corresponds to the type of data an object represents. The most common modes you will encounter in R are:</p> <p>Mode              Type of data   (abbreviation)    </p> <p>Numeric (num)     Numbers such floating point/decimals (1.0, 0.5,                     3.14), there are also more specific numeric types                     (dbl - Double, int - Integer). These differences are                     not relevant for most beginners and pertain to how                     these values are stored in memory</p> <p>Character (chr)   A sequence of letters/numbers in single '' or double                     \" \" quotes</p> <p>Logical           Boolean values - TRUE or FALSE</p> <p>There are a few other modes (i.e.\u00a0\"complex\", \"raw\" etc.) but these are the three we will work with in this lesson.</p> <p>Data types are familiar in many programming languages, but also in natural language where we refer to them as the parts of speech, e.g.\u00a0nouns, verbs, adverbs, etc. Once you know if a word - perhaps an unfamiliar one - is a noun, you can probably guess you can count it and make it plural if there is more than one (e.g.\u00a01 Tuatara, or 2 Tuataras). If something is a adjective, you can usually change it into an adverb by adding \"-ly\" (e.g.\u00a0jejune vs. jejunely). Depending on the context, you may need to decide if a word is in one category or another (e.g \"cut\" may be a noun when it's on your finger, or a verb when you are preparing vegetables). These concepts have important analogies when working with R objects.</p> <p>Exercise: Create objects and check their modes</p> <p>Create the following objects in R, then use the <code>mode()</code> function to verify their modes. Try to guess what the mode will be before you look at the solution</p> <ol> <li><code>chromosome_name &lt;- 'chr02'</code></li> <li><code>od_600_value &lt;- 0.47</code></li> <li><code>chr_position &lt;- '1001701'</code></li> <li><code>spock &lt;- TRUE</code></li> <li><code>pilot &lt;- Earhart</code></li> </ol> Solution <p><code>{r, echo = FALSE, purl = FALSE} chromosome_name &lt;- 'chr02' od_600_value &lt;- 0.47 chr_position &lt;- '1001701' spock &lt;- TRUE pilot &lt;- Earhart</code></p> <p><code>{r, purl = FALSE} mode(chromosome_name) mode(od_600_value) mode(chr_position) mode(spock) mode(pilot)</code> {: .solution} {: .challenge}</p> <p>Notice from the solution that even if a series of numbers is given as a value R will consider them to be in the \"character\" mode if they are enclosed as single or double quotes. Also, notice that you cannot take a string of alphanumeric characters (e.g.\u00a0Earhart) and assign as a value for an object. In this case, R looks for an object named <code>Earhart</code> but since there is no object, no assignment can be made. If <code>Earhart</code> did exist, then the mode of <code>pilot</code> would be whatever the mode of <code>Earhart</code> was originally. If we want to create an object called <code>pilot</code> that was the name \"Earhart\", we need to enclose <code>Earhart</code> in quotation marks.</p> <p>r</p> <p><code>pilot &lt;- \"Earhart\" mode(pilot)</code></p>"},{"location":"01-r-basics/#mathematical-and-functional-operations-on-objects","title":"Mathematical and functional operations on objects","text":"<p>Once an object exists (which by definition also means it has a mode), R can appropriately manipulate that object. For example, objects of the numeric modes can be added, multiplied, divided, etc. R provides several mathematical (arithmetic) operators including:</p> <p>Operator     Description</p> <p>+           addition   -           subtraction   *           multiplication   /            division   ^ or **   exponentiation   a%/%b        integer division (division where the remainder is discarded)   a%%b         modulus (returns the remainder after division)</p> <p>These can be used with literal numbers:</p> <p><code>{r, purl = FALSE} (1 + (5 ** 0.5))/2</code></p> <p>and importantly, can be used on any object that evaluates to (i.e.\u00a0interpreted by R) a numeric object:</p> <p><code>{r, echo = FALSE, purl = FALSE} human_chr_number &lt;- 23</code></p> <p>```{r, purl = FALSE} # multiply the object 'human_chr_number' by 2</p> <p>human_chr_number * 2</p> <pre><code>&gt; ## Exercise: Compute the golden ratio\n&gt;\n&gt; One approximation of the golden ratio (\u03c6) can be found by taking the sum of 1\n&gt; and the square root of 5, and dividing by 2 as in the example above. Compute\n&gt; the golden ratio to 3 digits of precision using the `sqrt()` and `round()`\n&gt; functions. Hint: remember the `round()` function can take 2 arguments.\n&gt;\n&gt;&gt; ## Solution\n&gt;&gt; ```{r, purl = FALSE}\n&gt;&gt; round((1 + sqrt(5))/2, digits = 3)\n&gt;&gt; ```\n&gt;&gt; Notice that you can place one function inside of another.\n&gt; {: .solution}\n{: .challenge}\n\n## Vectors\n\nVectors are probably the\nmost used commonly used object type in R. \n**A vector is a collection of values that are all of the same type (numbers, characters, etc.)**. \nOne of the most common\nways to create a vector is to use the `c()` function - the \"concatenate\" or\n\"combine\" function. Inside the function you may enter one or more values; for\nmultiple values, separate each value with a comma:\n\n```{r, purl = FALSE}\n# Create the SNP gene name vector\n\nsnp_genes &lt;- c(\"OXTR\", \"ACTN3\", \"AR\", \"OPRM1\")\n</code></pre> <p>Vectors always have a mode and a length. You can check these with the <code>mode()</code> and <code>length()</code> functions respectively. Another useful function that gives both of these pieces of information is the <code>str()</code> (structure) function.</p> <p><code>{r, purl = FALSE} # Check the mode, length, and structure of 'snp_genes' mode(snp_genes) length(snp_genes) str(snp_genes)</code></p> <p>Vectors are quite important in R. Another data type that we will work with later in this lesson, data frames, are collections of vectors. What we learn here about vectors will pay off even more when we start working with data frames.</p>"},{"location":"01-r-basics/#creating-and-subsetting-vectors","title":"Creating and subsetting vectors","text":"<p>Let's create a few more vectors to play around with:</p> <p>```{r, purl = FALSE} # Some interesting human SNPs # while accuracy is important, typos in the data won't hurt you here</p> <p>snps \\&lt;- c(\"rs53576\", \"rs1815739\", \"rs6152\", \"rs1799971\") snp_chromosomes \\&lt;- c(\"3\", \"11\", \"X\", \"6\") snp_positions \\&lt;- c(8762685, 66560624, 67545785, 154039662)</p> <pre><code>Once we have vectors, one thing we may want to do is specifically retrieve one\nor more values from our vector. To do so, we use **bracket notation**. We type\nthe name of the vector followed by square brackets. In those square brackets\nwe place the index (e.g. a number) in that bracket as follows:\n\n```{r, purl = FALSE}\n# get the 3rd value in the snp vector\nsnp[3]\n</code></pre> <p>In R, every item your vector is indexed, starting from the first item (1) through to the final number of items in your vector. You can also retrieve a range of numbers:</p> <p>```{r, purl = FALSE} # get the 1st through 3rd value in the snp vector</p> <p>snp[1:3]</p> <pre><code>If you want to retrieve several (but not necessarily sequential) items from\na vector, you pass a **vector of indices**; a vector that has the numbered\npositions you wish to retrieve.\n\n```{r, purl = FALSE}\n# get the 1st, 3rd, and 4th value in the snp vector\n\nsnp[c(1, 3, 4)]\n</code></pre> <p>There are additional (and perhaps less commonly used) ways of subsetting a vector (see these examples). Also, several of these subsetting expressions can be combined:</p> <p><code>{r, purl = FALSE} # get the 1st through the 3rd value, and 4th value in the snp vector # yes, this is a little silly in a vector of only 4 values. snp[c(1:3,4)]</code></p>"},{"location":"01-r-basics/#adding-to-removing-or-replacing-values-in-existing-vectors","title":"Adding to, removing, or replacing values in existing vectors","text":"<p>Once you have an existing vector, you may want to add a new item to it. To do so, you can use the <code>c()</code> function again to add your new value:</p> <p><code>{r, purl = FALSE} # add the gene \"CYP1A1\" and \"APOA5\" to our list of snp genes # this overwrites our existing vector snp_genes &lt;- c(snp_genes, \"CYP1A1\", \"APOA5\")</code></p> <p>We can verify that \"snp_genes\" contains the new gene entry</p> <p><code>{r, purl = FALSE} snp_genes</code></p> <p>Using a negative index will return a version of a vector with that index's value removed:</p> <p><code>{r, purl = FALSE} snp_genes[-6]</code></p> <p>We can remove that value from our vector by overwriting it with this expression:</p> <p><code>{r, purl = FALSE} snp_genes &lt;- snp_genes[-6] snp_genes</code></p> <p>We can also explicitly rename or add a value to our index using double bracket notation:</p> <p><code>{r, purl = FALSE} snp_genes[6]&lt;- \"APOA5\" snp_genes</code></p>"},{"location":"01-r-basics/#exercise-examining-and-subsetting-vectors","title":"Exercise: Examining and subsetting vectors","text":"<p>Answer the following questions to test your knowledge of vectors</p> <p>Which of the following are true of vectors in R? A) All vectors have a mode or a length\\ B) All vectors have a mode and a length\\ C) Vectors may have different lengths\\ D) Items within a vector may be of different modes\\ E) You can use the <code>c()</code> to add one or more items to an existing vector\\ F) You can use the <code>c()</code> to add a vector to an exiting vector\\ &gt; &gt; ## Solution &gt; &gt; A) False - Vectors have both of these properties\\ &gt; B) True\\ &gt; C) True\\ &gt; D) False - Vectors have only one mode (e.g.\u00a0numeric, character); all items in\\ &gt; a vector must be of this mode. &gt; E) True\\ &gt; F) True\\ {: .solution} {: .challenge}</p>"},{"location":"01-r-basics/#logical-subsetting","title":"Logical Subsetting","text":"<p>There is one last set of cool subsetting capabilities we want to introduce. It is possible within R to retrieve items in a vector based on a logical evaluation or numerical comparison. For example, let's say we wanted get all of the SNPs in our vector of SNP positions that were greater than 100,000,000. We could index using the '&gt;' (greater than) logical operator:</p> <p><code>{r, purl = FALSE} snp_positions[snp_positions &gt; 100000000]</code></p> <p>In the square brackets you place the name of the vector followed by the comparison operator and (in this case) a numeric value. Some of the most common logical operators you will use in R are:</p> <p>Operator   Description</p> <p>\\&lt;         less than   \\&lt;=        less than or equal to   &gt;         greater than   &gt;=        greater than or equal to   ==         exactly equal to   !=         not equal to   !x         not x   a | b     a or b   a &amp; b      a and b</p>"},{"location":"01-r-basics/#the-magic-of-programming","title":"The magic of programming","text":"<p>The reason why the expression <code>snp_positions[snp_positions &gt; 100000000]</code> works can be better understood if you examine what the expression \"snp_positions &gt; 100000000\" evaluates to:</p> <p><code>{r, purl = FALSE} snp_positions &gt; 100000000</code></p> <p>The output above is a logical vector, the 4th element of which is TRUE. When you pass a logical vector as an index, R will return the true values:</p> <p><code>{r, purl = FALSE} snp_positions[c(FALSE, FALSE, FALSE, TRUE)]</code></p> <p>If you have never coded before, this type of situation starts to expose the \"magic\" of programming. We mentioned before that in the bracket notation you take your named vector followed by brackets which contain an index: named_vector[index]. The \"magic\" is that the index needs to evaluate to a number. So, even if it does not appear to be an integer (e.g.\u00a01, 2, 3), as long as R can evaluate it, we will get a result. That our expression <code>snp_positions[snp_positions &gt; 100000000]</code> evaluates to a number can be seen in the following situation. If you wanted to know which index (1, 2, 3, or 4) in our vector of SNP positions was the one that was greater than 100,000,000?</p> <p>We can use the <code>which()</code> function to return the indices of any item that evaluates as TRUE in our comparison:</p> <p><code>{r, purl = FALSE} which(snp_positions &gt; 100000000)</code></p> <p>Why this is important</p> <p>Often in programming we will not know what inputs and values will be used when our code is executed. Rather than put in a pre-determined value (e.g 100000000) we can use an object that can take on whatever value we need. So for example:</p> <p><code>{r, purl = FALSE} snp_marker_cutoff &lt;- 100000000 snp_positions[snp_positions &gt; snp_marker_cutoff]</code></p> <p>Ultimately, it's putting together flexible, reusable code like this that gets at the \"magic\" of programming! {: .callout}</p>"},{"location":"01-r-basics/#a-few-final-vector-tricks","title":"A few final vector tricks","text":"<p>Finally, there are a few other common retrieve or replace operations you may want to know about. First, you can check to see if any of the values of your vector are missing (i.e.\u00a0are <code>NA</code>, that stands for <code>not avaliable</code>). Missing data will get a more detailed treatment later, but the <code>is.NA()</code> function will return a logical vector, with TRUE for any NA value:</p> <p>```{r, purl = FALSE} # current value of 'snp_genes': # chr [1:7] \"OXTR\" \"ACTN3\" \"AR\" \"OPRM1\" \"CYP1A1\" NA \"APOA5\"</p> <p>is.na(snp_genes)</p> <pre><code>Sometimes, you may wish to find out if a specific value (or several values) is\npresent a vector. You can do this using the comparison operator `%in%`, which\nwill return TRUE for any value in your collection that is in\nthe vector you are searching:\n\n```{r, purl = FALSE}\n# current value of 'snp_genes':\n# chr [1:7] \"OXTR\" \"ACTN3\" \"AR\" \"OPRM1\" \"CYP1A1\" NA \"APOA5\"\n\n# test to see if \"ACTN3\" or \"APO5A\" is in the snp_genes vector\n# if you are looking for more than one value, you must pass this as a vector\n\nc(\"ACTN3\",\"APOA5\") %in% snp_genes\n</code></pre>"},{"location":"01-r-basics/#review-exercise-1","title":"Review Exercise 1","text":"<p>What data modes are the following vectors? a. <code>snps</code>\\ b. <code>snp_chromosomes</code>\\ c.\u00a0<code>snp_positions</code></p>"},{"location":"01-r-basics/#solution","title":"Solution","text":"<p><code>{r, purl = FALSE} mode(snps) mode(snp_chromosomes) mode(snp_positions)</code> {: .solution} {: .challenge}</p>"},{"location":"01-r-basics/#review-exercise-2","title":"Review Exercise 2","text":"<p>Add the following values to the specified vectors: a. To the <code>snps</code> vector add: \"rs662799\"\\ b. To the <code>snp_chromosomes</code> vector add: 11\\ c.\u00a0To the <code>snp_positions</code> vector add: 116792991</p>"},{"location":"01-r-basics/#solution_1","title":"Solution","text":"<p><code>{r, purl = FALSE} snps &lt;- c(snps, \"rs662799\") snps snp_chromosomes &lt;- c(snp_chromosomes, \"11\") # did you use quotes? snp_chromosomes snp_positions &lt;- c(snp_positions, 116792991) snp_positions</code> {: .solution} {: .challenge}</p>"},{"location":"01-r-basics/#review-exercise-3","title":"Review Exercise 3","text":"<p>Make the following change to the <code>snp_genes</code> vector:</p> <p>Hint: Your vector should look like this in 'Environment': <code>chr [1:7] \"OXTR\" \"ACTN3\" \"AR\" \"OPRM1\" \"CYP1A1\" NA \"APOA5\"</code>. If not recreate the vector by running this expression: <code>snp_genes &lt;- c(\"OXTR\", \"ACTN3\", \"AR\", \"OPRM1\", \"CYP1A1\", NA, \"APOA5\")</code></p> <p>a.  Create a new version of <code>snp_genes</code> that does not contain CYP1A1     and then\\ b.  Add 2 NA values to the end of <code>snp_genes</code></p>"},{"location":"01-r-basics/#solution_2","title":"Solution","text":"<p><code>{r, purl = FALSE} snp_genes &lt;- snp_genes[-5] snp_genes &lt;- c(snp_genes, NA, NA) snp_genes</code> {: .solution} {: .challenge}</p>"},{"location":"01-r-basics/#review-exercise-4","title":"Review Exercise 4","text":"<p>Using indexing, create a new vector named <code>combined</code> that contains: - The the 1st value in <code>snp_genes</code> - The 1st value in <code>snps</code> - The 1st value in <code>snp_chromosomes</code> - The 1st value in <code>snp_positions</code></p>"},{"location":"01-r-basics/#solution_3","title":"Solution","text":"<p><code>{r, purl = FALSE} combined &lt;- c(snp_genes[1], snps[1], snp_chromosomes[1], snp_positions[1]) combined</code> {: .solution} {: .challenge}</p>"},{"location":"01-r-basics/#review-exercise-5","title":"Review Exercise 5","text":"<p>What type of data is <code>combined</code>?</p>"},{"location":"01-r-basics/#solution_4","title":"Solution","text":"<p><code>{r, purl = FALSE} typeof(combined)</code> {: .solution} {: .challenge}</p>"},{"location":"01-r-basics/#bonus-material-lists","title":"Bonus material: Lists","text":"<p>Lists are quite useful in R, but we won't be using them in the genomics lessons. That said, you may come across lists in the way that some bioinformatics programs may store and/or return data to you. One of the key attributes of a list is that, unlike a vector, a list may contain data of more than one mode. Learn more about creating and using lists using this nice tutorial. In this one example, we will create a named list and show you how to retrieve items from the list.</p> <p><code>{r, purl = FALSE} # Create a named list using the 'list' function and our SNP examples # Note, for easy reading we have placed each item in the list on a separate line # Nothing special about this, you can do this for any multiline commands # To run this command, make sure the entire command (all 4 lines) are highlighted # before running # Note also, as we are doing all this inside the list() function use of the # '=' sign is good style snp_data &lt;- list(genes = snp_genes,                  refference_snp = snps,                  chromosome = snp_chromosomes,                  position = snp_positions) # Examine the structure of the list str(snp_data)</code></p> <p>To get all the values for the <code>position</code> object in the list, we use the <code>$</code> notation:</p> <p>```{r, purl = FALSE} # return all the values of position object</p> <p>snp_data$position</p> <pre><code>To get the first value in the `position` object, use the `[]` notation to index:\n\n```{r, purl = FALSE}\n# return first value of the position object\n\nsnp_data$position[1]\n</code></pre>"},{"location":"02-data-prelude/","title":"Introduction to the example dataset and file type","text":"<p>Info</p> <p>keypoints: - The dataset comes from a real world experiment in E. coli. - Publicly available FASTQ files can be downloaded from NCBI SRA. - Several steps are taken outside of R/RStudio to create VCF files from   FASTQ files. - VCF files store variant calls in a special format.</p> <p>objectives: - Know what the example dataset represents - Know the concepts of how VCF files are generated</p> <p>questions: - What data are we using in the lesson? - What are VCF files?</p>"},{"location":"02-data-prelude/#preface","title":"Preface","text":"<p>The Intro to R and RStudio for Genomics is a part of the Genomics Data Carpentry lessons. In this lesson we will learn the necessary skill sets for R and RStudio and apply them directly to a real next-generation sequencing (NGS) data in the variant calling format (VCF) file type. Previous Genomics Data Carpentry lessons teach learners how to generate a VCF file from FASTQ files downloaded from NCBI Sequence Read Archive (SRA), so we won't cover that here. Instead, in this episode we will give a brief overview of the data and a what VCF file types are for those who wish to teach the Intro to R and RStudio for Genomics lesson independently of the Genomics Data Carpentry lessons.</p> <p>This dataset was selected for several reasons, including:</p> <ul> <li>Simple, but iconic NGS-problem: Examine a population where we want     to characterize changes in sequence a priori</li> <li>Dataset publicly available - in this case through the NCBI SRA     (http://www.ncbi.nlm.nih.gov/sra)</li> </ul>"},{"location":"02-data-prelude/#introduction-to-the-dataset","title":"Introduction to the dataset","text":"<p>Microbes are ideal organisms for exploring 'Long-term Evolution Experiments' (LTEEs) - thousands of generations can be generated and stored in a way that would be virtually impossible for more complex eukaryotic systems. In Tenaillon et al 2016, 12 populations of Escherichia coli were propagated for more than 50,000 generations in a glucose-limited minimal medium. This medium was supplemented with citrate which E. coli cannot metabolize in the aerobic conditions of the experiment. Sequencing of the populations at regular time points reveals that spontaneous citrate-using mutants (Cit+) appeared in a population of E.coli (designated Ara-3) at around 31,000 generations. It should be noted that spontaneous Cit+ mutants are extraordinarily rare - inability to metabolize citrate is one of the defining characters of the E. coli species. Eventually, Cit+ mutants became the dominant population as the experimental growth medium contained a high concentration of citrate relative to glucose. Around the same time that this mutation emerged, another phenotype become prominent in the Ara-3 population. Many E. coli began to develop excessive numbers of mutations, meaning they became hypermutable.</p> <p>Strains from generation 0 to generation 50,000 were sequenced, including ones that were both Cit+ and Cit- and hypermutable in later generations.</p> <p>For the purposes of this workshop we're going to be working with 3 of the sequence reads from this experiment.</p> <p>SRA Run Number     Clone      Generation    Cit       Hypermutable   Read      Sequencing                                                                        Length    Depth</p> <p>SRR2589044         REL2181A   5,000         Unknown   None           150       60.2</p> <p>SRR2584863         REL7179B   15,000        Unknown   None           150       88</p> <p>SRR2584866         REL11365   50,000        Cit+      plus           150       138.3</p> <p>We want to be able to look at differences in mutation rates between hypermutable and non-hypermutable strains. We also want to analyze the sequences to figure out what changes occurred in genomes to make the strains Cit+. Ultimately, we will use R to answer the questions:</p> <ul> <li>How many base pair changes are there between the Cit+ and Cit-     strains?</li> <li>What are the base pair changes between strains?</li> </ul>"},{"location":"02-data-prelude/#how-vcf-files-are-generated","title":"How VCF files are generated","text":"<p>Publicly accessible sequencing files in FASTQ formats can be downloaded from NCBI SRA. However, at FASTQ files contain unaligned sequences of varying quality, and requires clean up and alignment steps for variants to be called from the reference genome.</p> <p>Five steps are taken to transform FASTQ files to variant calls contained in VCF files and at each step, specialized non-R based bioinformatics tools that are used:</p> <p><pre><code>&lt;center&gt;\n</code></pre> <code>&lt;img src=\"../fig/variant_calling_workflow.png\" alt=\"variant calling workflow. Sequence reads (FASTQ files), Quality control (FASTQ files), Alignment to Genome (SAM/BAM files), Alignment cleanup (BAM file ready for variant calling), Variant Calling (VCF file)\" style=\"width: 250px;\"/&gt;</code> <pre><code>&lt;/center&gt;\n</code></pre></p>"},{"location":"02-data-prelude/#how-variant-calls-are-stored-in-vcf-files","title":"How variant calls are stored in VCF files","text":"<p>VCF files contain variants that were called against a reference genome. These files are slightly more complicated than regular tables you can open using programs like Excel and contain two sections: header and records.</p> <p>Below you will see the header (which describes the format), the time and date the file was created, the version of bcftools that was used, the command line parameters used, and some additional information:</p> <pre><code>##fileformat=VCFv4.2\n##FILTER=&lt;ID=PASS,Description=\"All filters passed\"&gt;\n##bcftoolsVersion=1.8+htslib-1.8\n##bcftoolsCommand=mpileup -O b -o results/bcf/SRR2584866_raw.bcf -f data/ref_genome/ecoli_rel606.fasta results/bam/SRR2584866.aligned.sorted.bam\n##reference=file://data/ref_genome/ecoli_rel606.fasta\n##contig=&lt;ID=CP000819.1,length=4629812&gt;\n##ALT=&lt;ID=*,Description=\"Represents allele(s) other than observed.\"&gt;\n##INFO=&lt;ID=INDEL,Number=0,Type=Flag,Description=\"Indicates that the variant is an INDEL.\"&gt;\n##INFO=&lt;ID=IDV,Number=1,Type=Integer,Description=\"Maximum number of reads supporting an indel\"&gt;\n##INFO=&lt;ID=IMF,Number=1,Type=Float,Description=\"Maximum fraction of reads supporting an indel\"&gt;\n##INFO=&lt;ID=DP,Number=1,Type=Integer,Description=\"Raw read depth\"&gt;\n##INFO=&lt;ID=VDB,Number=1,Type=Float,Description=\"Variant Distance Bias for filtering splice-site artefacts in RNA-seq data (bigger is better)\",Version=\n##INFO=&lt;ID=RPB,Number=1,Type=Float,Description=\"Mann-Whitney U test of Read Position Bias (bigger is better)\"&gt;\n##INFO=&lt;ID=MQB,Number=1,Type=Float,Description=\"Mann-Whitney U test of Mapping Quality Bias (bigger is better)\"&gt;\n##INFO=&lt;ID=BQB,Number=1,Type=Float,Description=\"Mann-Whitney U test of Base Quality Bias (bigger is better)\"&gt;\n##INFO=&lt;ID=MQSB,Number=1,Type=Float,Description=\"Mann-Whitney U test of Mapping Quality vs Strand Bias (bigger is better)\"&gt;\n##INFO=&lt;ID=SGB,Number=1,Type=Float,Description=\"Segregation based metric.\"&gt;\n##INFO=&lt;ID=MQ0F,Number=1,Type=Float,Description=\"Fraction of MQ0 reads (smaller is better)\"&gt;\n##FORMAT=&lt;ID=PL,Number=G,Type=Integer,Description=\"List of Phred-scaled genotype likelihoods\"&gt;\n##FORMAT=&lt;ID=GT,Number=1,Type=String,Description=\"Genotype\"&gt;\n##INFO=&lt;ID=ICB,Number=1,Type=Float,Description=\"Inbreeding Coefficient Binomial test (bigger is better)\"&gt;\n##INFO=&lt;ID=HOB,Number=1,Type=Float,Description=\"Bias in the number of HOMs number (smaller is better)\"&gt;\n##INFO=&lt;ID=AC,Number=A,Type=Integer,Description=\"Allele count in genotypes for each ALT allele, in the same order as listed\"&gt;\n##INFO=&lt;ID=AN,Number=1,Type=Integer,Description=\"Total number of alleles in called genotypes\"&gt;\n##INFO=&lt;ID=DP4,Number=4,Type=Integer,Description=\"Number of high-quality ref-forward , ref-reverse, alt-forward and alt-reverse bases\"&gt;\n##INFO=&lt;ID=MQ,Number=1,Type=Integer,Description=\"Average mapping quality\"&gt;\n##bcftools_callVersion=1.8+htslib-1.8\n##bcftools_callCommand=call --ploidy 1 -m -v -o results/bcf/SRR2584866_variants.vcf results/bcf/SRR2584866_raw.bcf; Date=Tue Oct  9 18:48:10 2018\n</code></pre> <p>Followed by information on each of the variations observed:</p> <pre><code>#CHROM  POS     ID      REF     ALT     QUAL    FILTER  INFO    FORMAT  results/bam/SRR2584866.aligned.sorted.bam\nCP000819.1      1521    .       C       T       207     .       DP=9;VDB=0.993024;SGB=-0.662043;MQSB=0.974597;MQ0F=0;AC=1;AN=1;DP4=0,0,4,5;MQ=60\nCP000819.1      1612    .       A       G       225     .       DP=13;VDB=0.52194;SGB=-0.676189;MQSB=0.950952;MQ0F=0;AC=1;AN=1;DP4=0,0,6,5;MQ=60\nCP000819.1      9092    .       A       G       225     .       DP=14;VDB=0.717543;SGB=-0.670168;MQSB=0.916482;MQ0F=0;AC=1;AN=1;DP4=0,0,7,3;MQ=60\nCP000819.1      9972    .       T       G       214     .       DP=10;VDB=0.022095;SGB=-0.670168;MQSB=1;MQ0F=0;AC=1;AN=1;DP4=0,0,2,8;MQ=60      GT:PL\nCP000819.1      10563   .       G       A       225     .       DP=11;VDB=0.958658;SGB=-0.670168;MQSB=0.952347;MQ0F=0;AC=1;AN=1;DP4=0,0,5,5;MQ=60\nCP000819.1      22257   .       C       T       127     .       DP=5;VDB=0.0765947;SGB=-0.590765;MQSB=1;MQ0F=0;AC=1;AN=1;DP4=0,0,2,3;MQ=60      GT:PL\nCP000819.1      38971   .       A       G       225     .       DP=14;VDB=0.872139;SGB=-0.680642;MQSB=1;MQ0F=0;AC=1;AN=1;DP4=0,0,4,8;MQ=60      GT:PL\nCP000819.1      42306   .       A       G       225     .       DP=15;VDB=0.969686;SGB=-0.686358;MQSB=1;MQ0F=0;AC=1;AN=1;DP4=0,0,5,9;MQ=60      GT:PL\nCP000819.1      45277   .       A       G       225     .       DP=15;VDB=0.470998;SGB=-0.680642;MQSB=0.95494;MQ0F=0;AC=1;AN=1;DP4=0,0,7,5;MQ=60\nCP000819.1      56613   .       C       G       183     .       DP=12;VDB=0.879703;SGB=-0.676189;MQSB=1;MQ0F=0;AC=1;AN=1;DP4=0,0,8,3;MQ=60      GT:PL\nCP000819.1      62118   .       A       G       225     .       DP=19;VDB=0.414981;SGB=-0.691153;MQSB=0.906029;MQ0F=0;AC=1;AN=1;DP4=0,0,8,10;MQ=59\nCP000819.1      64042   .       G       A       225     .       DP=18;VDB=0.451328;SGB=-0.689466;MQSB=1;MQ0F=0;AC=1;AN=1;DP4=0,0,7,9;MQ=60      GT:PL\n</code></pre> <p>The first few columns represent the information we have about a predicted variation.</p> <p>column                        info</p> <p>CHROM                         contig location where the variation                                 occurs</p> <p>POS                           position within the contig where the                                 variation occurs</p> <p>ID                            a <code>.</code> until we add annotation information</p> <p>REF                           reference genotype (forward strand)</p> <p>ALT                           sample genotype (forward strand)</p> <p>QUAL                          Phred-scaled probability that the                                 observed variant exists at this site                                 (higher is better)</p> <p>FILTER                        a <code>.</code> if no quality filters have been                                 applied, PASS if a filter is passed, or                                 the name of the filters this variant                                 failed</p> <p>In an ideal world, the information in the <code>QUAL</code> column would be all we needed to filter out bad variant calls. However, in reality we need to filter on multiple other metrics.</p> <p>The last two columns contain the genotypes and can be tricky to decode.</p> <p>column    info</p> <p>FORMAT    lists in order the metrics presented in the final column   results   lists the values associated with those metrics in order</p> <p>For our file, the metrics presented are GT:PL:GQ.</p> <p>metric                        definition</p> <p>AD, DP                        the depth per allele by sample and                                 coverage</p> <p>GT                            the genotype for the sample at this loci.                                 For a diploid organism, the GT field                                 indicates the two alleles carried by the                                 sample, encoded by a 0 for the REF                                 allele, 1 for the first ALT allele, 2 for                                 the second ALT allele, etc. A 0/0 means                                 homozygous reference, 0/1 is                                 heterozygous, and 1/1 is homozygous for                                 the alternate allele.</p> <p>PL                            the likelihoods of the given genotypes</p> <p>GQ                            the Phred-scaled confidence for the                                 genotype</p> <p>For more information on VCF files visit The Broad Institute's VCF guide.</p>"},{"location":"02-data-prelude/#references","title":"References","text":"<p>Tenaillon O, Barrick JE, Ribeck N, Deatherage DE, Blanchard JL, Dasgupta A, Wu GC, Wielgoss S, Cruveiller S, M\u00e9digue C, Schneider D, Lenski RE. Tempo and mode of genome evolution in a 50,000-generation experiment (2016) Nature. 536(7615): 165--170. Paper, Supplemental materials Data on NCBI SRA: https://trace.ncbi.nlm.nih.gov/Traces/sra/?study=SRP064605 Data on EMBL-EBI ENA: https://www.ebi.ac.uk/ena/data/view/PRJNA295606</p> <p>This episode was adapted from the Data Carpentry Genomic lessons:</p> <ul> <li>Project organization and management for     Genomics</li> <li>Data wrangling and processing for     genomics</li> </ul>"},{"location":"03-basics-factors-dataframes/","title":"R Basics continued - factors and data frames","text":"<p>Info</p> <p>keypoints:</p> <ul> <li>It is easy to import data into R from tabular formats including Excel.   However, you still need to check that R has imported and interpreted   your data correctly</li> <li>There are best practices for organizing your data (keeping it tidy)   and R is great for this</li> <li>Base R has many useful functions for manipulating your data, but all   of R's capabilities are greatly enhanced by software packages   developed by the community</li> </ul> <p>objectives:</p> <ul> <li>Explain the basic principle of tidy datasets</li> <li>Be able to load a tabular dataset using base R functions</li> <li>Be able to determine the structure of a data frame including its   dimensions and the datatypes of variables</li> <li>Be able to subset/retrieve values from a data frame</li> <li>Understand how R may coerce data into different modes</li> <li>Be able to change the mode of an object</li> <li>Understand that R uses factors to store and manipulate categorical   data</li> <li>Be able to manipulate a factor, including subsetting and reordering</li> <li>Be able to apply an arithmetic function to a data frame</li> <li>Be able to coerce the class of an object (including variables in a   data frame)</li> <li>Be able to import data from Excel</li> <li>Be able to save a data frame as a delimited file</li> </ul> <p>questions:</p> <ul> <li>How do I get started with tabular data (e.g.\u00a0spreadsheets) in R?</li> <li>What are some best practices for reading data into R?</li> <li>How do I save tabular data generated in R?</li> </ul>"},{"location":"03-basics-factors-dataframes/#working-with-spreadsheets-tabular-data","title":"Working with spreadsheets (tabular data)","text":"<p>A substantial amount of the data we work with in genomics will be tabular data, this is data arranged in rows and columns - also known as spreadsheets. We could write a whole lesson on how to work with spreadsheets effectively (actually we did). For our purposes, we want to remind you of a few principles before we work with our first set of example data:</p> <p>1) Keep raw data separate from analyzed data</p> <p>This is principle number one because if you can't tell which files are the original raw data, you risk making some serious mistakes (e.g.\u00a0drawing conclusion from data which have been manipulated in some unknown way).</p> <p>2) Keep spreadsheet data Tidy</p> <p>The simplest principle of Tidy data is that we have one row in our spreadsheet for each observation or sample, and one column for every variable that we measure or report on. As simple as this sounds, it's very easily violated. Most data scientists agree that significant amounts of their time is spent tidying data for analysis. Read more about data organization in our lesson and in this paper.</p> <p>3) Trust but verify</p> <p>Finally, while you don't need to be paranoid about data, you should have a plan for how you will prepare it for analysis. This a focus of this lesson. You probably already have a lot of intuition, expectations, assumptions about your data - the range of values you expect, how many values should have been recorded, etc. Of course, as the data get larger our human ability to keep track will start to fail (and yes, it can fail for small data sets too). R will help you to examine your data so that you can have greater confidence in your analysis, and its reproducibility.</p>"},{"location":"03-basics-factors-dataframes/#tip-keeping-you-raw-data-separate","title":"Tip: Keeping you raw data separate","text":"<p>When you work with data in R, you are not changing the original file you loaded that data from. This is different than (for example) working with a spreadsheet program where changing the value of the cell leaves you one \"save\"-click away from overwriting the original file. You have to purposely use a writing function (e.g.\u00a0<code>write.csv()</code>) to save data loaded into R. In that case, be sure to save the manipulated data into a new file. More on this later in the lesson. {: .callout}</p>"},{"location":"03-basics-factors-dataframes/#importing-tabular-data-into-r","title":"Importing tabular data into R","text":"<p>There are several ways to import data into R. For our purpose here, we will focus on using the tools every R installation comes with (so called \"base\" R) to import a comma-delimited file containing the results of our variant calling workflow. We will need to load the sheet using a function called <code>read.csv()</code>.</p> <p>Now, let's read in the file <code>combined_tidy_vcf.csv</code> which will be located in <code>/home/dcuser/r_data/</code>. Call this data <code>variants</code>. The first argument to pass to our <code>read.csv()</code> function is the file path for our data. The file path must be in quotes and now is a good time to remember to use tab autocompletion. If you use tab autocompletion you avoid typos and errors in file paths. Use it!</p> <p>```{r, eval = FALSE, purl = FALSE} ## read in a CSV file and save it as 'variants'</p> <p>variants \\&lt;- read.csv(\"/home/dcuser/r_data/combined_tidy_vcf.csv\")</p> <pre><code>```{r, echo = FALSE, eval = TRUE, purl = FALSE}\n## silently read in CSV file from FigShare\n\nvariants &lt;- read.csv(\"https://ndownloader.figshare.com/files/14632895\")\n</code></pre> <p>One of the first things you should notice is that in the Environment window, you have the <code>variants</code> object, listed as 801 obs. (observations/rows) of 29 variables (columns). Double-clicking on the name of the object will open a view of the data in a new tab.</p> <p><code>&lt;img src=\"../fig/rstudio_dataframeview.png\" alt=\"rstudio data frame view\" style=\"width: 1000px;\"/&gt;</code></p>"},{"location":"03-basics-factors-dataframes/#exercise-review-the-arguments-of-the-readcsv-function","title":"Exercise: Review the arguments of the <code>read.csv()</code> function","text":"<p>Before using the <code>read.csv()</code> function, use R's help feature to answer the following questions.</p> <p>Hint: Entering '?' before the function name and then running that line will bring up the help documentation. Also, when reading this particular help be careful to pay attention to the 'read.csv' expression under the 'Usage' heading. Other answers will be in the 'Arguments' heading.</p> <p>A)  What is the default parameter for 'header' in the <code>read.csv()</code>     function?</p> <p>B)  What argument would you have to change to read a file that was     delimited by semicolons (;) rather than commas?</p> <p>C)  What argument would you have to change to read file in which     numbers used commas for decimal separation (i.e.\u00a01,00)?</p> <p>D)  What argument would you have to change to read in only the first     10,000 rows of a very large file?</p>"},{"location":"03-basics-factors-dataframes/#solution","title":"Solution","text":"<p>A)  The <code>read.csv()</code> function has the argument 'header' set to TRUE     by default, this means the function always assumes the first row     is header information, (i.e.\u00a0column names)</p> <p>B)  The <code>read.csv()</code> function has the argument 'sep' set to \",\".     This means the function assumes commas are used as delimiters,     as you would expect. Changing this parameter (e.g.\u00a0<code>sep=\";\"</code>)     would now interpret semicolons as delimiters.</p> <p>C)  Although it is not listed in the <code>read.csv()</code> usage,     <code>read.csv()</code> is a \"version\" of the function <code>read.table()</code> and     accepts all its arguments. If you set <code>dec=\",\"</code> you could change     the decimal operator. We'd probably assume the delimiter is some     other character.</p> <p>D)  You can set <code>nrow</code> to a numeric value (e.g.\u00a0<code>nrow=10000</code>) to     choose how many rows of a file you read in. This may be useful     for very large files where not all the data is needed to test     some data cleaning steps you are applying.</p> <p>Hopefully, this exercise gets you thinking about using the provided help documentation in R. There are many arguments that exist, but which we wont have time to cover. Look here to get familiar with functions you use frequently, you may be surprised at what you find they can do. {: .solution} {: .challenge}</p>"},{"location":"03-basics-factors-dataframes/#summarizing-subsetting-and-determining-the-structure-of-a-data-frame","title":"Summarizing, subsetting, and determining the structure of a data frame.","text":"<p>A data frame is the standard way in R to store tabular data. A data fame could also be thought of as a collection of vectors, all of which have the same length. Using only two functions, we can learn a lot about out data frame including some summary statistics as well as well as the \"structure\" of the data frame. Let's examine what each of these functions can tell us:</p> <p>```{r, purl = FALSE} ## get summary statistics on a data frame</p> <p>summary(variants)</p> <pre><code>Our data frame had 29 variables, so we get 29 fields that summarize the data.\nThe `QUAL`, `IMF`, and `VDB` variables (and several others) are\nnumerical data and so you get summary statistics on the min and max values for\nthese columns, as well as mean, median, and interquartile ranges. Many of the\nother variables (e.g. `sample_id`) are treated as characters data (more on this\nin a bit).\n\nThere is a lot to work with, so we will subset the first three columns into a\nnew data frame using the `data.frame()` function.\n\n```{r, purl = FALSE}\n## put the first three columns of variants into a new data frame called subset\n\nsubset&lt;-data.frame(variants[,c(1:3,6)])\n</code></pre> <p>Now, let's use the <code>str()</code> (structure) function to look a little more closely at how data frames work:</p> <p>```{r, purl = FALSE} ## get the structure of a data frame</p> <p>str(subset)</p> <pre><code>Ok, thats a lot up unpack! Some things to notice.\n\n- the object type `data.frame` is displayed in the first row along with its\n  dimensions, in this case 801 observations (rows) and 4 variables (columns)\n- Each variable (column) has a name (e.g. `sample_id`). This is followed\n  by the object mode (e.g. chr, int, etc.). Notice that before each\n  variable name there is a `$` - this will be important later.\n\n## Introducing Factors\n\nFactors are the final major data structure we will introduce in our R genomics\nlessons. Factors can be thought of as vectors which are specialized for\ncategorical data. Given R's specialization for statistics, this make sense since\ncategorial and continuous variables are usually treated differently. Sometimes\nyou may want to have data treated as a factor, but in other cases, this may be\nundesirable.\n\nLet's see the value of treating some of which are categorical in nature as\nfactors. Let's take a look at just the alternate alleles\n\n```{r, purl = FALSE}\n## extract the \"ALT\" column to a new object\n\nalt_alleles &lt;- subset$ALT\n</code></pre> <p>Let's look at the first few items in our factor using <code>head()</code>:</p> <p><code>{r, purl = FALSE} head(alt_alleles)</code></p> <p>There are 801 alleles (one for each row). To simplify, lets look at just the single-nuleotide alleles (SNPs). We can use some of the vector indexing skills from the last episode.</p> <p><code>{r, purl = FALSE} snps &lt;- c(alt_alleles[alt_alleles==\"A\"],   alt_alleles[alt_alleles==\"T\"],   alt_alleles[alt_alleles==\"G\"],   alt_alleles[alt_alleles==\"C\"])</code></p> <p>This leaves us with a vector of the 701 alternative alleles which were single nucleotides. Right now, they are being treated a characters, but we could treat them as categories of SNP. Doing this will enable some nice features. For example, we can try to generate a plot of this character vector as it is right now:</p> <p><code>{r, purl = FALSE, fig.show='hide'} plot(snps)</code></p> <p>Whoops! Though the <code>plot()</code> function will do its best to give us a quick plot, it is unable to do so here. One way to fix this it to tell R to treat the SNPs as categories (i.e.\u00a0a factor vector); we will create a new object to avoid confusion using the <code>factor()</code> function:</p> <p><code>{r, purl = FALSE} factor_snps &lt;- factor(snps)</code></p> <p>Let's learn a little more about this new type of vector:</p> <p><code>{r, purl = FALSE} str(factor_snps)</code></p> <p>What we get back are the categories (\"A\",\"C\",\"G\",\"T\") in our factor; these are called \"Levels\". Levels are the different categories contained in a factor. By default, R will organize the levels in a factor in alphabetical order. So the first level in this factor is \"A\".</p> <p>For the sake of efficiency, R stores the content of a factor as a vector of integers, which an integer is assigned to each of the possible levels. Recall levels are assigned in alphabetical order. In this case, the first item in our <code>factor_snps</code> object is \"A\", which happens to be the 1st level of our factor, ordered alphabetically. This explains the sequence of \"1\"s (\"Factor w/ 4 levels\"A\",\"C\",\"G\",\"T\": 1 1 1 1 1 1 1 1 1 1 ...\"), since\"A\" is the first level, and the first few items in our factor are all \"A\"s.</p> <p>We can see how many items in our vector fall into each category:</p> <p><code>{r, purl = FALSE} summary(factor_snps)</code></p> <p>As you can imagine, this is already useful when you want to generate a tally.</p>"},{"location":"03-basics-factors-dataframes/#tip-treating-objects-as-categories-without-changing-their-mode","title":"Tip: treating objects as categories without changing their mode","text":"<p>You don't have to make an object a factor to get the benefits of treating an object as a factor. See what happens when you use the <code>as.factor()</code> function on <code>factor_snps</code>. To generate a tally, you can sometimes also use the <code>table()</code> function; though sometimes you may need to combine both (i.e. <code>table(as.factor(object))</code>) {: .callout}</p>"},{"location":"03-basics-factors-dataframes/#plotting-and-ordering-factors","title":"Plotting and ordering factors","text":"<p>One of the most common uses for factors will be when you plot categorical values. For example, suppose we want to know how many of our variants had each possible SNP we could generate a plot:</p> <p><code>{r, purl = FALSE} plot(factor_snps)</code></p> <p>This isn't a particularly pretty example of a plot but it works. We'll be learning much more about creating nice, publication-quality graphics later in this lesson.</p> <p>If you recall, factors are ordered alphabetically. That might make sense, but categories (e.g., \"red\", \"blue\", \"green\") often do not have an intrinsic order. What if we wanted to order our plot according to the numerical value (i.e., in descending order of SNP frequency)? We can enforce an order on our factors:</p> <p><code>{r, purl = FALSE} ordered_factor_snps &lt;- factor(factor_snps, levels = names(sort(table(factor_snps))))</code></p> <p>Let's deconstruct this from the inside out (you can try each of these commands to see why this works):</p> <ol> <li>We create a table of <code>factor_snps</code> to get the frequency of each SNP:     <code>table(factor_snps)</code></li> <li>We sort this table: <code>sort(table(factor_snps))</code>; use the     <code>decreasing =</code> parameter for this function if you wanted to change     from the default of FALSE</li> <li>Using the <code>names</code> function gives us just the character names of the     table sorted by frequencies:<code>names(sort(table(factor_snps)))</code></li> <li>The <code>factor</code> function is what allows us to create a factor. We give     it the <code>factor_snps</code> object as input, and use the <code>levels=</code>     parameter to enforce the ordering of the levels.</li> </ol> <p>Now we see our plot has be reordered:</p> <p><code>{r, purl = FALSE} plot(ordered_factor_snps)</code></p> <p>Factors come in handy in many places when using R. Even using more sophisticated plotting packages such as ggplot2 will sometimes require you to understand how to manipulate factors.</p>"},{"location":"03-basics-factors-dataframes/#tip-packages-in-r-what-are-they-and-why-do-we-use-them","title":"Tip: Packages in R -- what are they and why do we use them?","text":"<p>Packages are simply collections of functions and/or data that can be used to extend the capabilities of R beyond the core functionality that comes with it by default. There are useful R packages available that span all types of statistical analysis, data visualization, and more. The main place that R packages are installed from is a website called CRAN (the Comprehensive R Archive Network). Many thousands of R packages are available there, and when you use the built-in R function <code>install.packages()</code>, it will look for a CRAN repository to install from. So, for example, to install tidyverse packages such as <code>dplyr</code> and <code>ggplot2</code> (which you'll do in the next few lessons), you would use the following command:</p> <pre><code># install a package from CRAN\ninstall.packages(\"ggplot2\")\n</code></pre> <p>{: .callout}</p>"},{"location":"03-basics-factors-dataframes/#subsetting-data-frames","title":"Subsetting data frames","text":"<p>Next, we are going to talk about how you can get specific values from data frames, and where necessary, change the mode of a column of values.</p> <p>The first thing to remember is that a data frame is two-dimensional (rows and columns). Therefore, to select a specific value we will will once again use <code>[]</code> (bracket) notation, but we will specify more than one value (except in some cases where we are taking a range).</p> <p>The subsetting notation is very similar to what we learned for vectors. The key differences include:</p> <ul> <li>Typically provide two values separated by commas: data.frame[row,     column]</li> <li>In cases where you are taking a continuous range of numbers use a     colon between the numbers (start:stop, inclusive)</li> <li>For a non continuous set of numbers, pass a vector using <code>c()</code></li> <li>Index using the name of a column(s) by passing them as vectors using     <code>c()</code></li> </ul> <p>Finally, in all of the subsetting exercises above, we printed values to the screen. You can create a new data frame object by assigning them to a new object name:</p> <p>```{r, purl = FALSE} # create a new data frame containing only observations from SRR2584863</p> <p>SRR2584863_variants \\&lt;- variants[variants$sample_id == \"SRR2584863\",]</p>"},{"location":"03-basics-factors-dataframes/#exercise-subsetting-a-data-frame","title":"Exercise: Subsetting a data frame","text":"<p>Try the following indices and functions and try to figure out what they return</p> <p>a.  <code>variants[1,1]</code></p> <p>b.  <code>variants[2,4]</code></p> <p>c.  <code>variants[801,29]</code></p> <p>d.  <code>variants[2, ]</code></p> <p>e.  <code>variants[-1, ]</code></p> <p>f.  <code>variants[1:4,1]</code></p> <p>g.  <code>variants[1:10,c(\"REF\",\"ALT\")]</code></p> <p>h.  <code>variants[,c(\"sample_id\")]</code></p> <p>i.  <code>head(variants)</code></p> <p>j.  <code>tail(variants)</code></p> <p>k.  <code>variants$sample_id</code></p> <p>l.  <code>variants[variants$REF == \"A\",]</code></p>"},{"location":"03-basics-factors-dataframes/#solution_1","title":"Solution","text":"<p>a.  </p> <pre><code>variants[1,1]\n</code></pre> <p>b.  </p> <pre><code>variants[2,4]\n</code></pre> <p>c.  </p> <pre><code>variants[801,29]\n</code></pre> <p>d.  </p> <pre><code>variants[2, ]\n</code></pre> <p>e.  <code>{r, echo = TRUE, eval = FALSE} variants[-1, ]</code></p> <p><code>{r, echo = FALSE, eval = TRUE} head(variants[-1, ])</code></p> <p>f.  </p> <pre><code>variants[1:4,1]\n</code></pre> <p>g.  </p> <pre><code>variants[1:10,c(\"REF\",\"ALT\")]\n</code></pre> <p>h.  <code>{r, echo = TRUE, eval = FALSE} variants[,c(\"sample_id\")]</code></p> <p><code>{r, echo = FALSE, eval = TRUE} head(variants[,c(\"sample_id\")])</code></p> <p>i.  </p> <pre><code>head(variants)\n</code></pre> <p>j.  </p> <pre><code>tail(variants)\n</code></pre> <p>k.  <code>{r, echo = TRUE, eval = FALSE} variants$sample_id</code></p> <p><code>{r, echo = FALSE, eval = TRUE} head(variants$sample_id)</code></p> <p>l.  <code>{r, echo = TRUE, eval = FALSE} variants[variants$REF == \"A\",]</code></p> <p><code>{r, echo = FALSE, eval = TRUE} head(variants[variants$REF == \"A\",])</code> {: .solution} {: .challenge}</p>"},{"location":"03-basics-factors-dataframes/#check-the-dimension-of-the-data-frame","title":"check the dimension of the data frame","text":"<p>dim(SRR2584863_variants)</p>"},{"location":"03-basics-factors-dataframes/#get-a-summary-of-the-data-frame","title":"get a summary of the data frame","text":"<p>summary(SRR2584863_variants)</p> <pre><code>## Coercing values in data frames\n\n&gt; ## Tip: coercion isn't limited to data frames\n&gt;\n&gt; While we are going to address coercion in the context of data frames\n&gt; most of these methods apply to other data structures, such as vectors\n{: .callout}\n\nSometimes, it is possible that R will misinterpret the type of data represented\nin a data frame, or store that data in a mode which prevents you from\noperating on the data the way you wish. For example, a long list of gene names\nisn't usually thought of as a categorical variable, the way that your\nexperimental condition (e.g. control, treatment) might be. More importantly,\nsome R packages you use to analyze your data may expect characters as input,\nnot factors. At other times (such as plotting or some statistical analyses) a\nfactor may be more appropriate. Ultimately, you should know how to change the\nmode of an object.\n\nFirst, its very important to recognize that coercion happens in R all the time.\nThis can be a good thing when R gets it right, or a bad thing when the result\nis not what you expect. Consider:\n\n```{r, purl = FALSE}\nsnp_chromosomes &lt;- c('3', '11', 'X', '6')\ntypeof(snp_chromosomes)\n</code></pre> <p>Although there are several numbers in our vector, they are all in quotes, so we have explicitly told R to consider them as characters. However, even if we removed the quotes from the numbers, R would coerce everything into a character:</p> <p><code>{r, purl = FALSE} snp_chromosomes_2 &lt;- c(3, 11, 'X', 6) typeof(snp_chromosomes_2) snp_chromosomes_2[1]</code></p> <p>We can use the <code>as.</code> functions to explicitly coerce values from one form into another. Consider the following vector of characters, which all happen to be valid numbers:</p> <p><code>{r, purl = FALSE} snp_positions_2 &lt;- c(\"8762685\", \"66560624\", \"67545785\", \"154039662\") typeof(snp_positions_2) snp_positions_2[1]</code></p> <p>Now we can coerce <code>snp_positions_2</code> into a numeric type using <code>as.numeric()</code>:</p> <p><code>{r, purl = FALSE} snp_positions_2 &lt;- as.numeric(snp_positions_2) typeof(snp_positions_2) snp_positions_2[1]</code></p> <p>Sometimes coercion is straight forward, but what would happen if we tried using <code>as.numeric()</code> on <code>snp_chromosomes_2</code></p> <p><code>{r, purl = FALSE} snp_chromosomes_2 &lt;- as.numeric(snp_chromosomes_2)</code></p> <p>If we check, we will see that an <code>NA</code> value (R's default value for missing data) has been introduced.</p> <p><code>{r, purl = FALSE} snp_chromosomes_2</code></p> <p>Trouble can really start when we try to coerce a factor. For example, when we try to coerce the <code>sample_id</code> column in our data frame into a numeric mode look at the result:</p> <p><code>{r, purl = FALSE} as.numeric(variants$sample_id)</code></p> <p>Strangely, it works! Almost. Instead of giving an error message, R returns numeric values, which in this case are the integers assigned to the levels in this factor. This kind of behavior can lead to hard-to-find bugs, for example when we do have numbers in a factor, and we get numbers from a coercion. If we don't look carefully, we may not notice a problem.</p> <p>If you need to coerce an entire column you can overwrite it using an expression like this one:</p> <p>```{r, purl = FALSE} # make the 'REF' column a character type column</p> <p>variants\\(REF &lt;- as.character(variants\\)REF)</p>"},{"location":"03-basics-factors-dataframes/#check-the-type-of-the-column","title":"check the type of the column","text":"<p>typeof(variants$REF)</p> <pre><code>## StringsAsFactors = ?\n\nLets summarize this section on coercion with a few take home messages.\n\n- When you explicitly coerce one data type into another (this is known as\n  **explicit coercion**), be careful to check the result. Ideally, you should try to see if its possible to avoid steps in your analysis that force you to\n  coerce.\n- R will sometimes coerce without you asking for it. This is called\n  (appropriately) **implicit coercion**. For example when we tried to create\n  a vector with multiple data types, R chose one type through implicit\n  coercion.\n- Check the structure (`str()`) of your data frames before working with them!\n\n\n&gt; ## Tip: coercion isn't limited to data frames\n&gt;\n&gt; Prior to R 4.0 when importing a data frame using any one of the `read.table()`\n&gt; functions such as `read.csv()` , the argument `StringsAsFactors` was by\n&gt; default\n&gt; set to true TRUE. Setting it to FALSE will treat any non-numeric column to\n&gt; a character type. `read.csv()` documentation, you will also see you can\n&gt; explicitly type your columns using the `colClasses` argument. Other R packages\n&gt; (such as the Tidyverse \"readr\") don't have this particular conversion issue,\n&gt; but many packages will still try to guess a data type.\n{: .callout}\n\n\n## Data frame bonus material: math, sorting, renaming\n\nHere are a few operations that don't need much explanation, but which are good\nto know.\n\nThere are lots of arithmetic functions you may want to apply to your data\nframe, covering those would be a course in itself (there is some starting\nmaterial [here](https://swcarpentry.github.io/r-novice-inflammation/15-supp-loops-in-depth/)). Our lessons will cover some additional summary statistical functions in\na subsequent lesson, but overall we will focus on data cleaning and\nvisualization.\n\nYou can use functions like `mean()`, `min()`, `max()` on an\nindividual column. Let's look at the \"DP\" or filtered depth. This value shows the number of filtered\nreads that support each of the reported variants.\n\n```{r, purl = FALSE}\nmax(variants$DP)\n</code></pre> <p>You can sort a data frame using the <code>order()</code> function:</p> <p><code>{r, purl = FALSE} sorted_by_DP &lt;- variants[order(variants$DP), ] head(sorted_by_DP$DP)</code></p> <p>You can rename columns:</p> <p>```{r, purl = FALSE} colnames(variants)[colnames(variants) == \"sample_id\"] \\&lt;- \"strain\"</p>"},{"location":"03-basics-factors-dataframes/#exercise","title":"Exercise","text":"<p>The <code>order()</code> function lists values in increasing order by default. Look at the documentation for this function and change <code>sorted_by_DP</code> to start with variants with the greatest filtered depth (\"DP\").</p>"},{"location":"03-basics-factors-dataframes/#solution_2","title":"Solution","text":"<p><code>{r, purl = FALSE}    sorted_by_DP &lt;- variants[order(variants$DP, decreasing = TRUE), ]    head(sorted_by_DP$DP)</code> {: .solution} {: .challenge}</p>"},{"location":"03-basics-factors-dataframes/#check-the-column-name-hint-names-are-returned-as-a-vector","title":"check the column name (hint names are returned as a vector)","text":"<p>colnames(variants)</p> <pre><code>## Saving your data frame to a file\n\nWe can save data to a file. We will save our `SRR2584863_variants` object\nto a .csv file using the `write.csv()` function:\n\n```{r, purl = FALSE}\nwrite.csv(SRR2584863_variants, file = \"../data/SRR2584863_variants.csv\")\n</code></pre> <p>The <code>write.csv()</code> function has some additional arguments listed in the help, but at a minimum you need to tell it what data frame to write to file, and give a path to a file name in quotes (if you only provide a file name, the file will be written in the current working directory).</p>"},{"location":"03-basics-factors-dataframes/#importing-data-from-excel","title":"Importing data from Excel","text":"<p>Excel is one of the most common formats, so we need to discuss how to make these files play nicely with R. The simplest way to import data from Excel is to save your Excel file in .csv format*. You can then import into R right away. Sometimes you may not be able to do this (imagine you have data in 300 Excel files, are you going to open and export all of them?).</p> <p>One common R package (a set of code with features you can download and add to your R installation) is the readxl package which can open and import Excel files. Rather than addressing package installation this second (we'll discuss this soon!), we can take advantage of RStudio's import feature which integrates this package. (Note: this feature is available only in the latest versions of RStudio such as is installed on our cloud instance).</p> <p>First, in the RStudio menu go to File, select Import Dataset, and choose From Excel... (notice there are several other options you can explore).</p> <p><code>&lt;img src=\"../fig/rstudio_import_menu.png \" alt=\"rstudio import menu\" style=\"width: 600px;\"/&gt;</code></p> <p>Next, under File/Url: click the <code>&lt;KBD&gt;</code>Browse<code>&lt;/KBD&gt;</code> button and navigate to the Ecoli_metadata.xlsx file located at <code>/home/dcuser/dc_sample_data/R</code>. You should now see a preview of the data to be imported:</p> <p><code>&lt;img src=\"../fig/rstudio_import_screen.png \" alt=\"rstudio import screen\" style=\"width: 1200px;\"/&gt;</code></p> <p>Notice that you have the option to change the data type of each variable by clicking arrow (drop-down menu) next to each column title. Under Import Options you may also rename the data, choose a different sheet to import, and choose how you will handle headers and skipped rows. Under Code Preview you can see the code that will be used to import this file. We could have written this code and imported the Excel file without the RStudio import function, but now you can choose your preference.</p> <p>In this exercise, we will leave the title of the data frame as Ecoli_metadata, and there are no other options we need to adjust. Click the <code>&lt;KBD&gt;</code>Import<code>&lt;/KBD&gt;</code> button to import the data.</p> <p>Finally, let's check the first few lines of the <code>Ecoli_metadata</code> data frame:</p> <p><code>{r, echo = FALSE, eval = TRUE, purl = FALSE, warning = FALSE} ## silently read in CSV file from CyVerse download.file(\"https://de.cyverse.org/dl/d/17FAE062-2673-417B-8544-77CC46974A37/Ecoli_metadata.xlsx\",               destfile = \"Ecoli_metadata.xlsx\") Ecoli_metadata &lt;- readxl::read_xlsx(\"Ecoli_metadata.xlsx\")</code></p> <p><code>{r, purl = FALSE} head(Ecoli_metadata)</code></p> <p>The type of this object is 'tibble', a type of data frame we will talk more about in the 'dplyr' section. If you needed a true R data frame you could coerce with <code>as.data.frame()</code>.</p>"},{"location":"03-basics-factors-dataframes/#exercise-putting-it-all-together-data-frames","title":"Exercise: Putting it all together - data frames","text":"<p>Using the <code>Ecoli_metadata</code> data frame created above, answer the following questions</p> <p>A)  What are the dimensions (# rows, # columns) of the data frame?</p> <p>B)  What are categories are there in the <code>cit</code> column? hint: treat     column as factor</p> <p>C)  How many of each of the <code>cit</code> categories are there?</p> <p>D)  What is the genome size for the 7th observation in this data set?</p> <p>E)  What is the median value of the variable <code>genome_size</code></p> <p>F)  Rename the column <code>sample</code> to <code>sample_id</code></p> <p>G)  Create a new column (name genome_size_bp) and set it equal to the     genome_size multiplied by 1,000,000</p> <p>H)  Save the edited Ecoli_metadata data frame as     \"exercise_solution.csv\" in your current working directory.</p>"},{"location":"03-basics-factors-dataframes/#solution_3","title":"Solution","text":"<p><code>{r, purl = FALSE} dim(Ecoli_metadata) levels(as.factor(Ecoli_metadata$cit)) table(as.factor(Ecoli_metadata$cit)) Ecoli_metadata[7,7] median(Ecoli_metadata$genome_size) colnames(Ecoli_metadata)[colnames(Ecoli_metadata) == \"sample\"] &lt;- \"sample_id\" Ecoli_metadata$genome_size_bp &lt;- Ecoli_metadata$genome_size * 1000000 write.csv(Ecoli_metadata, file = \"exercise_solution.csv\")</code> {: .solution} {: .challenge}</p>"},{"location":"04-bioconductor-vcfr/","title":"Using packages from Bioconductor","text":"<p>Info</p> <p>keypoints:</p> <ul> <li>Bioconductor is an alternative package repository for bioinformatics   packages.</li> <li>Installing packages from Bioconductor requires a new method, since it   is not compatible with the <code>install.packages()</code> function used for   CRAN.</li> <li>Check Bioconductor to see if there is a package relevant to your   analysis before writing code yourself.</li> </ul> <p>objectives:</p> <ul> <li>Describe what the Bioconductor repository is and what it is used for</li> <li>Describe how Bioconductor differs from CRAN</li> <li>Search Bioconductor for relevant packages</li> <li>Install a package from Bioconductor</li> </ul> <p>questions:</p> <ul> <li>How do I use packages from the Bioconductor repository?</li> </ul>"},{"location":"04-bioconductor-vcfr/#installing-packages-from-somewhere-else-besides-cran","title":"Installing packages from somewhere else besides CRAN?","text":"<p>So far we have told you about using packages that are included in the base installation of R (this is what comes with R 'out of the box'), and packages that you can install from CRAN (the Comprehensive R Archive Network), which is the primary place many people look for supplemental R packages to install. However, not all R packages are available on CRAN. For bioinformatics-related packages in particular, there is another repository that has many powerful packages that you can install. It is called Bioconductor and it is a repository specifically focused on bioinformatics packages. Bioconductor has a mission of \"promot[ing] the statistical analysis and comprehension of current and emerging high-throughput biological assays.\" This means that many if not all of the packages available on Bioconductor are focused on the analysis of biological data, and that it can be a great place to look for tools to help you analyze your -omics datasets!</p>"},{"location":"04-bioconductor-vcfr/#so-how-do-i-use-it","title":"So how do I use it?","text":"<p>Since access to the Bioconductor repository is not built in to base R 'out of the box', there are a couple steps needed to install packages from this alternative source. We will work through the steps (only 2!) to install a package to help with the VCF analysis we are working on, but you can use the same approach to install any of the many thousands of available packages.</p> <p>[screenshot of bioconductor homepage]{.image .placeholder original-image-src=\"../fig/bioconductor_website_screenshot.jpg\" original-image-title=\"fig:\"}</p>"},{"location":"04-bioconductor-vcfr/#first-install-the-biocmanager-package","title":"First, install the <code>BiocManager</code> package","text":"<p>The first step is to install a package that is on CRAN, <code>BiocManager</code>. This package will allow us to use it to install packages from Bioconductor. You can think of Bioconductor kind of like an alternative app store for your phone, except instead of apps you are installing packages, and instead of your phone it's your local R package library.</p> <p><code>{r install-biocmanager, eval = FALSE} # install the BiocManager from CRAN using the base R install.packages() function install.packages(\"BiocManager\")</code></p> <p>To check if this worked (and also so you can make a note of the version for reproducibility purposes), you can run <code>BiocManager::version()</code> and it should give you the version number.</p> <p><code>{r check-bioconductor-version, eval = FALSE} # to make sure it worked, check the version BiocManager::version()</code></p>"},{"location":"04-bioconductor-vcfr/#second-install-the-vcfr-package-from-bioconductor-using-biocmanager","title":"Second, install the vcfR package from Bioconductor using <code>BiocManager</code>","text":"<p><code>{r install-vcfR, eval = FALSE} # install the vcfR package from bioconductor using BiocManager::install() BiocManager::install(\"vcfR\")</code> Depending on your particular system, you may need to also allow it to install some dependencies or update installed packages in order to successfully complete the process.</p>"},{"location":"04-bioconductor-vcfr/#heads-up-installing-vcfr-may-take-a-while-due-to-numerous-dependencies","title":"Head's Up: Installing vcfR may take a while due to numerous dependencies","text":"<p>Just be aware that installing packages that have many dependencies can take a while.</p> <p>{: .callout}</p>"},{"location":"04-bioconductor-vcfr/#note-installing-packages-from-bioconductor-vs-from-cran","title":"Note: Installing packages from Bioconductor vs from CRAN","text":"<p>Some packages begin by being available only on Bioconductor, and then later move to CRAN. <code>vcfR</code> is one such package, which originally was only available from Bioconductor, but is currently available from CRAN. The other thing to know is that <code>BiocManager::install()</code> will also install packages from CRAN (it is a wrapper around <code>install.packages()</code> that adds some extra features). There are other benefits to using <code>BiocManager::install()</code> for Bioconductor packages, many of which are outlined here. In short, Bioconductor packages have a release cycle that is different from CRAN and the <code>install()</code> function is aware of that difference, so it helps to keep package versions in line with one another in a way that doesn't generally happen with the base R <code>install.packages()</code>.</p> <p>{: .callout}</p>"},{"location":"04-bioconductor-vcfr/#search-for-bioconductor-packages-based-on-your-analysis-needs","title":"Search for Bioconductor packages based on your analysis needs","text":"<p>While we are only focusing in this workshop on VCF analyses, there are hundreds or thousands of different types of data and analyses that bioinformaticians may want to work with. Sometimes you may get a new dataset and not know exactly where to start with analyzing or visualizing it. The Bioconductor package search view can be a great way to browse through the packages that are available.</p> <p>[screenshot of bioconductor search]{.image .placeholder original-image-src=\"../fig/bioconductor_search.jpg\" original-image-title=\"fig:\"}</p> <p>In bioinformatics, there are often many different tools that can be used in a particular instance. The authors of <code>vcfR</code> have compiled some of them. One of those packages that is available from Bioconductor is called <code>VariantAnnotation</code> and may also be of interest to those working with vcf files in R.</p>"},{"location":"04-bioconductor-vcfr/#tip-searching-for-packages-on-the-bioconductor-website","title":"Tip: Searching for packages on the Bioconductor website","text":"<p>There are several thousand packages available through the Bioconductor website. It can be a bit of a challenge to find what you want, but one helpful resource is the package search page.</p> <p>{: .callout}</p>"},{"location":"04-bioconductor-vcfr/#challenge","title":"Challenge","text":"<ul> <li>Use the <code>BiocManager::available()</code> function to see what packages     are available matching a search term.</li> <li>Use the     biocViews     interface to search for packages of interest.</li> </ul> <p>You may or may not want to try installing the package, since not all dependencies always install easily. However, this will at least let you see what is available. {: .challenge}</p>"},{"location":"04-bioconductor-vcfr/#tip-refreshing-the-rstudio-package-view-after-installing","title":"Tip: Refreshing the RStudio package view after installing","text":"<p>If you install a package from Bioconductor, you may need to refresh the RStudio package view to see it in your list. You can do this by clicking the \"Refresh\" button in the Packages pane of RStudio.</p> <p>{: .callout}</p>"},{"location":"04-bioconductor-vcfr/#resources","title":"Resources","text":"<ul> <li>Bioconductor</li> <li>Bioconductor package     search</li> <li>CRAN</li> </ul>"},{"location":"05-dplyr/","title":"Data Wrangling and Analyses with Tidyverse","text":"<p>Info</p> <p>keypoints:</p> <ul> <li>Use the <code>dplyr</code> package to manipulate data frames.</li> <li>Use <code>glimpse()</code> to quickly look at your data frame.</li> <li>Use <code>select()</code> to choose variables from a data frame.</li> <li>Use <code>filter()</code> to choose data based on values.</li> <li>Use <code>mutate()</code> to create new variables.</li> <li>Use <code>group_by()</code> and <code>summarize()</code> to work with subsets of data.</li> </ul> <p>objectives: - Describe what the <code>dplyr</code> package in R is used for. - Apply common <code>dplyr</code> functions to manipulate data in R. - Employ the 'pipe' operator to link together a sequence of functions. - Employ the 'mutate' function to apply other chosen functions to   existing columns and create new columns of data. - Employ the 'split-apply-combine' concept to split the data into   groups, apply analysis to each group, and combine the results.</p> <p>questions: How can I manipulate data frames without repeating myself?</p> <p>Bracket subsetting is handy, but it can be cumbersome and difficult to read, especially for complicated operations.</p> <p>Luckily, the <code>dplyr</code> package provides a number of very useful functions for manipulating data frames in a way that will reduce repetition, reduce the probability of making errors, and probably even save you some typing. As an added bonus, you might even find the <code>dplyr</code> grammar easier to read.</p> <p>Here we're going to cover some of the most commonly used functions as well as using pipes (<code>%&gt;%</code>) to combine them:</p> <ol> <li><code>glimpse()</code></li> <li><code>select()</code></li> <li><code>filter()</code></li> <li><code>group_by()</code></li> <li><code>summarize()</code></li> <li><code>mutate()</code></li> <li><code>pivot_longer</code> and <code>pivot_wider</code></li> </ol> <p>Packages in R are sets of additional functions that let you do more stuff in R. The functions we've been using, like <code>str()</code>, come built into R; packages give you access to more functions. You need to install a package and then load it to be able to use it.</p> <p><code>{r, eval = FALSE, purl = FALSE} install.packages(\"dplyr\") ## installs dplyr package install.packages(\"tidyr\") ## installs tidyr package install.packages(\"ggplot2\") ## installs ggplot2 package install.packages(\"readr\") ## install readr package</code></p> <p>You might get asked to choose a CRAN mirror -- this is asking you to choose a site to download the package from. The choice doesn't matter too much; I'd recommend choosing the RStudio mirror.</p> <p><code>{r, message = FALSE, purl = FALSE} library(\"dplyr\")          ## loads in dplyr package to use library(\"tidyr\")          ## loads in tidyr package to use library(\"ggplot2\")          ## loads in ggplot2 package to use library(\"readr\")          ## load in readr package to use</code></p> <p>You only need to install a package once per computer, but you need to load it every time you open a new R session and want to use that package.</p>"},{"location":"05-dplyr/#tip-installing-packages","title":"Tip: Installing packages","text":"<p>It may be temping to install the <code>tidyverse</code> package, as it contains many useful collection of packages for this lesson and beyond. However, when teaching or following this lesson, we advise that participants install <code>dplyr</code>, <code>readr</code>, <code>ggplot2</code>, and <code>tidyr</code> individually as shown above. Otherwise, a substaial amount of the lesson will be spend waiting for the installation to complete. {: .callout}</p>"},{"location":"05-dplyr/#what-is-dplyr","title":"What is dplyr?","text":"<p>The package <code>dplyr</code> is a fairly new (2014) package that tries to provide easy tools for the most common data manipulation tasks. This package is also included in the <code>tidyverse</code> package, which is a collection of eight different packages (<code>dplyr</code>, <code>ggplot2</code>, <code>tibble</code>, <code>tidyr</code>, <code>readr</code>, <code>purrr</code>, <code>stringr</code>, and <code>forcats</code>). It is built to work directly with data frames. The thinking behind it was largely inspired by the package <code>plyr</code> which has been in use for some time but suffered from being slow in some cases.<code>dplyr</code> addresses this by porting much of the computation to C++. An additional feature is the ability to work with data stored directly in an external database. The benefits of doing this are that the data can be managed natively in a relational database, queries can be conducted on that database, and only the results of the query returned.</p> <p>This addresses a common problem with R in that all operations are conducted in memory and thus the amount of data you can work with is limited by available memory. The database connections essentially remove that limitation in that you can have a database that is over 100s of GB, conduct queries on it directly and pull back just what you need for analysis in R.</p>"},{"location":"05-dplyr/#loading-csv-files-in-tidy-style","title":"Loading .csv files in tidy style","text":"<p>The Tidyverse's <code>readr</code> package provides its own unique way of loading .csv files in to R using <code>read_csv()</code>, which is similar to <code>read.csv()</code>. <code>read_csv()</code> allows users to load in their data faster, doesn't create row names, and allows you to access non-standard variable names (ie. variables that start with numbers of contain spaces), and outputs your data on the R console in a tidier way. In short, it's a much friendlier way of loading in potentially messy data.</p> <p>Now let's load our vcf .csv file using <code>read_csv()</code>:</p> <p><code>{r, include = FALSE, echo = FALSE, eval = TRUE, purl = FALSE} variants &lt;- read_csv(\"../data/combined_tidy_vcf.csv\")</code></p>"},{"location":"05-dplyr/#taking-a-quick-look-at-data-frames","title":"Taking a quick look at data frames","text":"<p>Similar to <code>str()</code>, which comes built into R, <code>glimpse()</code> is a <code>dplyr</code> function that (as the name suggests) gives a glimpse of the data frame.</p> <p><code>{r, echo = FALSE, eval = TRUE, purl = FALSE} glimpse(variants)</code></p> <p>In the above output, we can already gather some information about <code>variants</code>, such as the number of rows and columns, column names, type of vector in the columns, and the first few entries of each column. Although what we see is similar to outputs of <code>str()</code>, this method gives a cleaner visual output.</p>"},{"location":"05-dplyr/#selecting-columns-and-filtering-rows","title":"Selecting columns and filtering rows","text":"<p>To select columns of a data frame, use <code>select()</code>. The first argument to this function is the data frame (<code>variants</code>), and the subsequent arguments are the columns to keep.</p> <p><code>{r, echo = TRUE, eval = TRUE, purl = FALSE} select(variants, sample_id, REF, ALT, DP)</code></p> <p>To select all columns except certain ones, put a \"-\" in front of the variable to exclude it.</p> <p><code>{r, echo = TRUE, eval = TRUE, purl = FALSE} select(variants, -CHROM)</code></p> <p><code>dplyr</code> also provides useful functions to select columns based on their names. For instance, <code>ends_with()</code> allows you to select columns that ends with specific letters. For instance, if you wanted to select columns that end with the letter \"B\":</p> <pre><code>select(variants, ends_with(\"B\"))\n</code></pre> <p>To choose rows, use <code>filter()</code>:</p> <p><code>{r, echo = TRUE, eval = TRUE, purl = FALSE} filter(variants, sample_id == \"SRR2584863\")</code></p> <p><code>filter()</code> will keep all the rows that match the conditions that are provided. Here are a few examples:</p> <pre><code># rows for which the reference genome has T or G\nfilter(variants, REF %in% c(\"T\", \"G\"))\n# rows that have TRUE in the column INDEL\nfilter(variants, INDEL)\n# rows that don't have missing data in the IDV column\nfilter(variants, !is.na(IDV))\n</code></pre> <p>We have a column titled \"QUAL\". This is a Phred-scaled confidence score that a polymorphism exists at this position given the sequencing data. Lower QUAL scores indicate low probability of a polymorphism existing at that site. <code>filter()</code> can be useful for selecting mutations that have a QUAL score above a certain threshold:</p> <pre><code># rows with QUAL values greater than or equal to 100\nfilter(variants, QUAL &gt;= 100)\n</code></pre> <p><code>filter()</code> allows you to combine multiple conditions. You can separate them using a <code>,</code> as arguments to the function, they will be combined using the <code>&amp;</code> (AND) logical operator. If you need to use the <code>|</code> (OR) logical operator, you can specify it explicitly:</p> <pre><code># this is equivalent to:\n#   filter(variants, sample_id == \"SRR2584863\" &amp; QUAL &gt;= 100)\nfilter(variants, sample_id == \"SRR2584863\", QUAL &gt;= 100)\n# using `|` logical operator\nfilter(variants, sample_id == \"SRR2584863\", (MQ &gt;= 50 | QUAL &gt;= 100))\n</code></pre>"},{"location":"05-dplyr/#challenge","title":"Challenge","text":"<p>Create a table that contains all the columns with the letter \"i\" and column \"POS\", without columns \"Indiv\" and \"FILTER\". Hint: look at for a function called <code>contains()</code>, which can be found in the help documentation for ends with we just covered (<code>?ends_with</code>). Note that contains() is not case sensistive.</p> <p>We can also get to <code>variants_result</code> in one line of code:</p>"},{"location":"05-dplyr/#solution","title":"Solution","text":"<pre><code># First, we select \"POS\" and all columns with letter \"i\". This will contain columns Indiv and FILTER. \nvariants_subset &lt;- select(variants, POS, contains(\"i\"))\n# Next, we remove columns Indiv and FILTER\nvariants_result &lt;- select(variants_subset, -Indiv, -FILTER)\nvariants_result\n</code></pre>"},{"location":"05-dplyr/#alternative-solution","title":"Alternative solution","text":"<pre><code>variants_result &lt;- select(variants, POS, contains(\"i\"), -Indiv, -FILTER)\nvariants_result\n</code></pre> <p>{: .solution} {: .challenge}</p>"},{"location":"05-dplyr/#challenge_1","title":"Challenge","text":"<p>Select all the mutations that occurred between the positions 1e6 (one million) and 2e6 (inclusive) that have a QUAL greater than 200, and exclude INDEL mutations. Hint: to flip logical values such as TRUE to a FALSE, we can use to negation symbol \"!\". (eg. !TRUE == FALSE).</p>"},{"location":"05-dplyr/#solution_1","title":"Solution","text":"<pre><code>filter(variants, POS &gt;= 1e6 &amp; POS &lt;= 2e6, QUAL &gt; 200, !INDEL)\n</code></pre> <p>{: .solution} {: .challenge}</p>"},{"location":"05-dplyr/#pipes","title":"Pipes","text":"<p>But what if you wanted to select and filter? We can do this with pipes. Pipes, are a fairly recent addition to R. Pipes let you take the output of one function and send it directly to the next, which is useful when you need to many things to the same data set. It was possible to do this before pipes were added to R, but it was much messier and more difficult. Pipes in R look like <code>%&gt;%</code> and are made available via the <code>magrittr</code> package, which is installed as part of <code>dplyr</code>. If you use RStudio, you can type the pipe with <code>&lt;kbd&gt;</code>Ctrl<code>&lt;/kbd&gt;</code> + <code>&lt;kbd&gt;</code>Shift<code>&lt;/kbd&gt;</code> + <code>&lt;kbd&gt;</code>M<code>&lt;/kbd&gt;</code> if you're using a PC, or <code>&lt;kbd&gt;</code>Cmd<code>&lt;/kbd&gt;</code> + <code>&lt;kbd&gt;</code>Shift<code>&lt;/kbd&gt;</code> + <code>&lt;kbd&gt;</code>M<code>&lt;/kbd&gt;</code> if you're using a Mac.</p> <p><code>{r, echo = TRUE, eval = TRUE, purl = FALSE} variants %&gt;%   filter(sample_id == \"SRR2584863\") %&gt;%   select(REF, ALT, DP)</code></p> <p>In the above code, we use the pipe to send the <code>variants</code> data set first through <code>filter()</code>, to keep rows where <code>sample_id</code> matches a particular sample, and then through <code>select()</code> to keep only the <code>REF</code>, <code>ALT</code>, and <code>DP</code> columns. Since <code>%&gt;%</code> takes the object on its left and passes it as the first argument to the function on its right, we don't need to explicitly include the data frame as an argument to the <code>filter()</code> and <code>select()</code> functions any more.</p> <p>Some may find it helpful to read the pipe like the word \"then\". For instance, in the above example, we took the data frame <code>variants</code>, then we <code>filter</code>ed for rows where <code>sample_id</code> was SRR2584863, then we <code>select</code>ed the <code>REF</code>, <code>ALT</code>, and <code>DP</code> columns, then we showed only the first six rows. The <code>dplyr</code> functions by themselves are somewhat simple, but by combining them into linear workflows with the pipe, we can accomplish more complex manipulations of data frames.</p> <p>If we want to create a new object with this smaller version of the data we can do so by assigning it a new name:</p> <p><code>{r, purl = FALSE} SRR2584863_variants &lt;- variants %&gt;%   filter(sample_id == \"SRR2584863\") %&gt;%   select(REF, ALT, DP)</code></p> <p>This new object includes all of the data from this sample. Let's look at just the first six rows to confirm it's what we want:</p> <p><code>{r, purl = FALSE} SRR2584863_variants</code></p> <p>Similar to <code>head()</code> and <code>tail()</code> functions, we can also look at the first or last six rows using tidyverse function <code>slice()</code>. Slice is a more versatile function that allows users to specify a range to view:</p> <pre><code>SRR2584863_variants %&gt;% slice(1:6)\n</code></pre> <pre><code>SRR2584863_variants %&gt;% slice(10:25)\n</code></pre>"},{"location":"05-dplyr/#exercise-pipe-and-filter","title":"Exercise: Pipe and filter","text":"<p>Starting with the <code>variants</code> data frame, use pipes to subset the data to include only observations from SRR2584863 sample, where the filtered depth (DP) is at least 10. Showing only 5th through 11th rows of columns <code>REF</code>, <code>ALT</code>, and <code>POS</code>.</p>"},{"location":"05-dplyr/#solution_2","title":"Solution","text":"<pre><code> variants %&gt;%\n filter(sample_id == \"SRR2584863\" &amp; DP &gt;= 10) %&gt;%\n slice(5:11) %&gt;%\n select(sample_id, DP, REF, ALT, POS)\n</code></pre> <p>{: .solution} {: .challenge}</p>"},{"location":"05-dplyr/#mutate","title":"Mutate","text":"<p>Frequently you'll want to create new columns based on the values in existing columns, for example to do unit conversions or find the ratio of values in two columns. For this we'll use the <code>dplyr</code> function <code>mutate()</code>.</p> <p>For example, we can convert the polymorphism confidence value QUAL to a probability value according to the formula:</p> <p>Probability = 1- 10 ^ -(QUAL/10)</p> <p>We can use <code>mutate</code> to add a column (<code>POLPROB</code>) to our <code>variants</code> data frame that shows the probability of a polymorphism at that site given the data.</p> <p><code>{r, purl = FALSE} variants %&gt;%   mutate(POLPROB = 1 - (10 ^ -(QUAL/10)))</code></p>"},{"location":"05-dplyr/#exercise","title":"Exercise","text":"<p>There are a lot of columns in our data set, so let's just look at the <code>sample_id</code>, <code>POS</code>, <code>QUAL</code>, and <code>POLPROB</code> columns for now. Add a line to the above code to only show those columns.</p>"},{"location":"05-dplyr/#solution_3","title":"Solution","text":"<pre><code>variants %&gt;%\n mutate(POLPROB = 1 - 10 ^ -(QUAL/10)) %&gt;%\n select(sample_id, POS, QUAL, POLPROB)\n</code></pre> <p>{: .solution} {: .challenge}</p>"},{"location":"05-dplyr/#group_by-and-summarize-functions","title":"group_by() and summarize() functions","text":"<p>Many data analysis tasks can be approached using the \"split-apply-combine\" paradigm: split the data into groups, apply some analysis to each group, and then combine the results. <code>dplyr</code> makes this very easy through the use of the <code>group_by()</code> function, which splits the data into groups.</p> <p>We can use <code>group_by()</code> to tally the number of mutations detected in each sample using the function <code>tally()</code>:</p> <p><code>{r, purl = FALSE, message = FALSE} variants %&gt;%   group_by(sample_id) %&gt;%   tally()</code></p> <p>Since counting or tallying values is a common use case for <code>group_by()</code>, an alternative function was created to bypasses <code>group_by()</code> using the function <code>count()</code>:</p> <p><code>{r, purl = FALSE, message = FALSE} variants %&gt;%   count(sample_id)</code></p> <p>When the data is grouped, <code>summarize()</code> can be used to collapse each group into a single-row summary. <code>summarize()</code> does this by applying an aggregating or summary function to each group.</p> <p>It can be a bit tricky at first, but we can imagine physically splitting the data frame by groups and applying a certain function to summarize the data.</p> <p><pre><code>&lt;center&gt;\n</code></pre> <code>&lt;img src=\"../fig/split_apply_combine.png\" alt=\"rstudio default session\" style=\"width: 500px;\"/&gt;</code> <pre><code>&lt;/center&gt;\n</code></pre> 1</p> <p>We can also apply many other functions to individual columns to get other summary statistics. For example,we can use built-in functions like <code>mean()</code>, <code>median()</code>, <code>min()</code>, and <code>max()</code>. These are called \"built-in functions\" because they come with R and don't require that you install any additional packages. By default, all R functions operating on vectors that contains missing data will return NA. It's a way to make sure that users know they have missing data, and make a conscious decision on how to deal with it. When dealing with simple statistics like the mean, the easiest way to ignore <code>NA</code> (the missing data) is to use <code>na.rm = TRUE</code> (<code>rm</code> stands for remove).</p> <p>So to view the mean, median, maximum, and minimum filtered depth (<code>DP</code>) for each sample:</p> <p><code>{r, purl = FALSE, message = FALSE} variants %&gt;%   group_by(sample_id) %&gt;%   summarize(     mean_DP = mean(DP),     median_DP = median(DP),     min_DP = min(DP),     max_DP = max(DP))</code></p>"},{"location":"05-dplyr/#challenge_2","title":"Challenge","text":"<ul> <li>How many mutations are INDELs?</li> </ul>"},{"location":"05-dplyr/#solution_4","title":"Solution","text":"<pre><code>variants %&gt;%\n  count(INDEL)\n</code></pre> <p>{: .solution} {: .challenge}</p>"},{"location":"05-dplyr/#reshaping-data-frames","title":"Reshaping data frames","text":"<p>It can sometimes be useful to transform the \"long\" tidy format, into the wide format. This transformation can be done with the <code>pivot_wider()</code> function provided by the <code>tidyr</code> package (also part of the <code>tidyverse</code>).</p> <p><code>pivot_wider()</code> takes a data frame as the first argument, and two arguments: the column name that will become the columns and the column name that will become the cells in the wide data.</p> <pre><code>variants_wide &lt;- variants %&gt;%\n  group_by(sample_id, CHROM) %&gt;%\n  summarize(mean_DP = mean(DP)) %&gt;%\n  pivot_wider(names_from = sample_id, values_from = mean_DP)\nvariants_wide\n</code></pre> <p>The opposite operation of <code>pivot_wider()</code> is taken care by <code>pivot_longer()</code>. We specify the names of the new columns, and here add <code>-CHROM</code> as this column shouldn't be affected by the reshaping:</p> <pre><code>variants_wide %&gt;%\n  pivot_longer(-CHROM, names_to = \"sample_id\", values_to = \"mean_DP\")\n</code></pre>"},{"location":"05-dplyr/#resources","title":"Resources","text":"<ul> <li> <p>Handy dplyr     cheatsheet</p> </li> <li> <p>Much of this lesson was copied or adapted from Jeff Hollister's     materials</p> </li> </ul> <ol> <li> <p>The figure was adapted from the Software Carpentry lesson, R for Reproducible Scientific Analysis \u21a9</p> </li> </ol>"},{"location":"06-data-visualization/","title":"Data Visualization with ggplot2","text":"<p>Info</p> <p>keypoints:</p> <ul> <li>ggplot2 is a powerful tool for high-quality plots</li> <li>ggplot2 provides a flexiable and readable grammar to build plots</li> </ul> <p>objectives:</p> <ul> <li>Describe the role of data, aesthetics, and geoms in ggplot functions.</li> <li>Choose the correct aesthetics and alter the geom parameters for a   scatter plot, histogram, or box plot.</li> <li>Layer multiple geometries in a single plot.</li> <li>Customize plot scales, titles, themes, and fonts.</li> <li>Apply a facet to a plot.</li> <li>Apply additional ggplot2-compatible plotting libraries.</li> <li>Save a ggplot to a file.</li> <li>List several resources for getting help with ggplot.</li> <li>List several resources for creating informative scientific plots.</li> </ul> <p>questions:</p> <ul> <li>What is ggplot2?</li> <li>What is mapping, and what is aesthetics?</li> <li>What is the process of creating a publication-quality plots with   ggplot in R?</li> </ul> <p>```{r, echo = FALSE, eval = TRUE, purl = FALSE} ## silently read in CSV file from FigShare</p>"},{"location":"06-data-visualization/#variants-readcsvhttpsndownloaderfigsharecomfiles14632895","title":"variants \\&lt;- read.csv(\"https://ndownloader.figshare.com/files/14632895\")","text":"<p>variants = read.csv(\"https://raw.githubusercontent.com/naupaka/vcfr-for-data-carpentry-draft/main/output/combined_tidy_vcf.csv\")</p> <pre><code>## Introduction to **`ggplot2`**\n\n&lt;img src=\"https://ggplot2.tidyverse.org/logo.png\" align=\"right\" alt=\"Line plot enclosed in hexagon shape with ggplot2 typed beneath and www.rstudio.com at the bottom.\"&gt;\n\n**`ggplot2`** is a plotting package that makes it simple to create complex plots from data in a data frame. It provides a more programmatic interface for specifying what variables to plot, how they are displayed, and general visual properties. Therefore, we only need minimal changes if the underlying data change or if we decide to change from a bar plot to a scatter plot. This helps in creating publication-quality plots with minimal amounts of adjustments and tweaking.\n\nThe **gg** in \u201c**ggplot**\u201d stands for \u201c**G**rammar of **G**raphics,\u201d which is an elegant yet powerful way to describe the making of scientific plots. In short, the grammar of graphics breaks down every plot into a few components, namely, a dataset, a set of geoms (visual marks that represent the data points), and a coordinate system. You can imagine this is a grammar that gives unique names to each component appearing in a plot and conveys specific information about data. With **ggplot**, graphics are built step by step by adding new elements.\n\nThe idea of **mapping** is crucial in **ggplot**. One familiar example is to *map* the value of one variable in a dataset to $x$ and the other to $y$. However, we often encounter datasets that include multiple (more than two) variables. In this case, **ggplot** allows you to *map* those other variables to visual marks such as **color** and **shape** (**aesthetics** or `aes`). One thing you may want to remember is the difference between **discrete** and **continuous** variables. Some aesthetics, such as the shape of dots, do not accept continuous variables. If forced to do so, R will give an error. This is easy to understand; we cannot create a continuum of shapes for a variable, unlike, say, color.\n\n**Tip:** when having doubts about whether a variable is [continuous or discrete](https://en.wikipedia.org/wiki/Continuous_or_discrete_variable), a quick way to check is to use the [`summary()`](https://www.geeksforgeeks.org/get-summary-of-results-produced-by-functions-in-r-programming-summary-function/) function. Continuous variables have descriptive statistics but not the discrete variables.\n\n## Installing `tidyverse`\n\n**`ggplot2`** belongs to the [**`tidyverse`** framework](https://www.tidyverse.org/). Therefore, we will start with loading the package **`tidyverse`**. If **`tidyverse`** is not already installed, then we need to install first. If it is already installed, then we can skip the following step:\n\n```{r install-tidyverse, echo=TRUE, eval=FALSE}\ninstall.packages(\"tidyverse\") # Installing tidyverse package, includes ggplot2 and other packages such as dplyr, readr, tidyr\n</code></pre> <p>Now, let's load the <code>tidyverse</code> package:</p> <p><code>{r load-tidyverse} library(tidyverse)</code></p> <p>As we can see from above output <code>ggplot2</code> has been already loaded along with other packages as part of the <code>tidyverse</code> framework.</p>"},{"location":"06-data-visualization/#loading-the-dataset","title":"Loading the dataset","text":"<p><code>{r load-the-dataset, echo=TRUE, eval=TRUE} variants = read_csv(\"https://raw.githubusercontent.com/naupaka/vcfr-for-data-carpentry-draft/main/output/combined_tidy_vcf.csv\")</code></p> <p>Explore the structure (types of columns and number of rows) of the dataset using dplyr's <code>glimpse()</code> (for more info, see the Data Wrangling and Analyses with Tidyverse episode)</p> <p><code>{r glimpse-at-the-data} glimpse(variants) # Show a snapshot of the rows and columns</code></p> <p>Alternatively, we can display the first a few rows (vertically) of the table using <code>head()</code>:</p> <p><code>{r head-of-the-data} head(variants)</code></p> <p>```{r, echo = FALSE, eval = TRUE, purl = FALSE} ## silently read in CSV file from FigShare</p>"},{"location":"06-data-visualization/#variants-readcsvhttpsndownloaderfigsharecomfiles14632895_1","title":"variants \\&lt;- read.csv(\"https://ndownloader.figshare.com/files/14632895\")","text":""},{"location":"06-data-visualization/#variants-readcsvhttpsrawgithubusercontentcomnaupakavcfr-for-data-carpentry-draftmainoutputcombined_tidy_vcfcsv","title":"variants = read.csv(\"https://raw.githubusercontent.com/naupaka/vcfr-for-data-carpentry-draft/main/output/combined_tidy_vcf.csv\")","text":"<pre><code>**`ggplot2`** functions like data in the **long** format, i.e., a column for every dimension (variable), and a row for every observation. Well-structured data will save you time when making figures with **`ggplot2`**\n\n**`ggplot2`** graphics are built step-by-step by adding new elements. Adding layers in this fashion allows for extensive flexibility and customization of plots, and more equally important the readability of the code.\n\nTo build a ggplot, we will use the following basic template that can be used for different types of plots:\n\n```{r, eval=FALSE}\nggplot(data = &lt;DATA&gt;, mapping = aes(&lt;MAPPINGS&gt;)) +  &lt;GEOM_FUNCTION&gt;()\n</code></pre> <ul> <li>use the <code>ggplot()</code> function and bind the plot to a specific data     frame using the <code>data</code> argument</li> </ul> <p><code>{r, eval=FALSE, purl=FALSE} ggplot(data = variants)</code></p> <ul> <li>define a mapping (using the aesthetic (<code>aes</code>) function), by     selecting the variables to be plotted and specifying how to present     them in the graph, e.g.\u00a0as x and y positions or characteristics such     as size, shape, color, etc.</li> </ul> <p><code>{r, eval=FALSE, purl=FALSE} ggplot(data = variants, aes(x = POS, y = DP))</code></p> <ul> <li>add 'geoms' -- graphical representations of the data in the plot     (points, lines, bars). <code>ggplot2</code> offers many different geoms; we     will use some common ones today, including:<ul> <li><code>geom_point()</code>     for scatter plots, dot plots, etc.</li> <li><code>geom_boxplot()</code>     for, well, boxplots!</li> <li><code>geom_line()</code>     for trend lines, time series, etc.</li> </ul> </li> </ul> <p>To add a geom to the plot use the <code>+</code> operator. Because we have two continuous variables, let's use <code>geom_point()</code> (i.e., a scatter plot) first:</p> <p><code>{r first-ggplot, purl=FALSE} ggplot(data = variants, aes(x = POS, y = DP)) +   geom_point()</code></p> <p>The <code>+</code> in the <code>ggplot2</code> package is particularly useful because it allows you to modify existing <code>ggplot</code> objects. This means you can easily set up plot templates and conveniently explore different types of plots, so the above plot can also be generated with code like this:</p> <p>```{r, first-ggplot-with-plus, eval=FALSE, purl=FALSE} # Assign plot to a variable coverage_plot \\&lt;- ggplot(data = variants, aes(x = POS, y = DP))</p>"},{"location":"06-data-visualization/#draw-the-plot","title":"Draw the plot","text":"<p>coverage_plot + geom_point()</p> <pre><code>**Notes**\n\n- Anything you put in the [`ggplot()`](https://ggplot2.tidyverse.org/reference/ggplot.html) function can be seen by any geom layers that you add (i.e., these are universal plot settings). This includes the x- and y-axis mapping you set up in [`aes()`](https://ggplot2.tidyverse.org/reference/aes.html).\n- You can also specify mappings for a given geom independently of the mappings defined globally in the [`ggplot()`](https://ggplot2.tidyverse.org/reference/ggplot.html) function.\n- The `+` sign used to add new layers must be placed at the end of the line containing the *previous* layer. If, instead, the `+` sign is added at the beginning of the line containing the new layer, **`ggplot2`** will not add the new layer and will return an error message.\n\n```{r, ggplot-with-plus-position, eval=FALSE, purl=FALSE}\n# This is the correct syntax for adding layers\ncoverage_plot +\n  geom_point()\n\n# This will not add the new layer and will return an error message\ncoverage_plot\n  + geom_point()\n</code></pre>"},{"location":"06-data-visualization/#building-your-plots-iteratively","title":"Building your plots iteratively","text":"<p>Building plots with <code>ggplot2</code> is typically an iterative process. We start by defining the dataset we'll use, lay out the axes, and choose a geom:</p> <p><code>{r create-ggplot-object, purl=FALSE} ggplot(data = variants, aes(x = POS, y = DP)) +   geom_point()</code></p> <p>Then, we start modifying this plot to extract more information from it. For instance, we can add transparency (<code>alpha</code>) to avoid over-plotting:</p> <p><code>{r adding-transparency, purl=FALSE} ggplot(data = variants, aes(x = POS, y = DP)) +     geom_point(alpha = 0.5)</code></p> <p>We can also add colors for all the points:</p> <p>```{r adding-colors, purl=FALSE}</p> <p>ggplot(data = variants, aes(x = POS, y = DP)) + geom_point(alpha = 0.5, color = \"blue\")</p> <pre><code>Or to color each species in the plot differently, you could use a vector as an input to the argument **color**. **`ggplot2`** will provide a different color corresponding to different values in the vector. Here is an example where we color with **`sample_id`**:\n\n```{r color-by-sample-1, purl=FALSE}\nggplot(data = variants, aes(x = POS, y = DP, color = sample_id)) +\n  geom_point(alpha = 0.5)\n</code></pre> <p>Notice that we can change the geom layer and colors will be still determined by <code>sample_id</code></p> <p><code>{r color-by-sample-2, purl=FALSE} ggplot(data = variants, aes(x = POS, y = DP, color = sample_id)) +   geom_point(alpha = 0.5)</code></p> <p>To make our plot more readable, we can add axis labels:</p> <p><code>{r add-axis-labels, purl=FALSE} ggplot(data = variants, aes(x = POS, y = DP, color = sample_id)) +   geom_point(alpha = 0.5) +   labs(x = \"Base Pair Position\",        y = \"Read Depth (DP)\")</code></p> <p>To add a main title to the plot, we use <code>ggtitle()</code>:</p> <p><code>{r add-main-title, purl=FALSE} ggplot(data = variants, aes(x = POS, y = DP, color = sample_id)) +   geom_point(alpha = 0.5) +   labs(x = \"Base Pair Position\",        y = \"Read Depth (DP)\") +   ggtitle(\"Read Depth vs. Position\")</code></p> <p>Now the figure is complete and ready to be exported and saved to a file. This can be achieved easily using <code>ggsave()</code>, which can write, by default, the most recent generated figure into different formats (e.g., <code>jpeg</code>, <code>png</code>, <code>pdf</code>) according to the file extension. So, for example, to create a pdf version of the above figure with a dimension of \\(6\\times4\\) inches:</p> <p><code>{r save-to-file, purl=FALSE} ggsave (\"depth.pdf\", width = 6, height = 4)</code></p> <p>If we check the current working directory, there should be a newly created file called <code>depth.pdf</code> with the above plot.</p> <p>To further customize the plot, we can change the default font format:</p> <p><code>{r change-font-family, purl=FALSE} ggplot(data = variants, aes(x = POS, y = DP, color = sample_id)) +   geom_point(alpha = 0.5) +   labs(x = \"Base Pair Position\",        y = \"Read Depth (DP)\") +   ggtitle(\"Read Depth vs. Position\") +   theme(text = element_text(family = \"Bookman\"))</code></p>"},{"location":"06-data-visualization/#challenge","title":"Challenge","text":"<p>Use what you just learned to create a scatter plot of mapping quality (<code>MQ</code>) over position (<code>POS</code>) with the samples showing in different colors. Make sure to give your plot relevant axis labels.</p>"},{"location":"06-data-visualization/#solution","title":"Solution","text":"<p><code>{r scatter-challenge, purl=FALSE}  ggplot(data = variants, aes(x = POS, y = MQ, color = sample_id)) +   geom_point() +   labs(x = \"Base Pair Position\",        y = \"Mapping Quality (MQ)\")</code> {: .solution} {: .challenge}</p>"},{"location":"06-data-visualization/#faceting","title":"Faceting","text":"<p><code>ggplot2</code> has a special technique called faceting that allows the user to split one plot into multiple plots (panels) based on a factor (variable) included in the dataset. We will use it to split our mapping quality plot into three panels, one for each sample.</p> <p><code>{r first-facet, purl=FALSE} ggplot(data = variants, aes(x = POS, y = MQ, color = sample_id)) +  geom_point() +  labs(x = \"Base Pair Position\",       y = \"Mapping Quality (MQ)\") +  facet_grid(. ~ sample_id)</code></p> <p>This looks okay, but it would be easier to read if the plot facets were stacked vertically rather than horizontally. The <code>facet_grid</code> geometry allows you to explicitly specify how you want your plots to be arranged via formula notation (<code>rows ~ columns</code>; the dot (<code>.</code>) indicates every other variable in the data i.e., no faceting on that side of the formula).</p> <p><code>{r second-facet, purl=FALSE} ggplot(data = variants, aes(x = POS, y = MQ, color = sample_id)) +  geom_point() +  labs(x = \"Base Pair Position\",       y = \"Mapping Quality (MQ)\") +  facet_grid(sample_id ~ .)</code></p> <p>Usually plots with white background look more readable when printed. We can set the background to white using the function <code>theme_bw()</code>. Additionally, you can remove the grid:</p> <p><code>{r facet-plot-white-bg, purl=FALSE} ggplot(data = variants, aes(x = POS, y = MQ, color = sample_id)) +   geom_point() +   labs(x = \"Base Pair Position\",        y = \"Mapping Quality (MQ)\") +   facet_grid(sample_id ~ .) +   theme_bw() +   theme(panel.grid = element_blank())</code></p>"},{"location":"06-data-visualization/#challenge_1","title":"Challenge","text":"<p>Use what you just learned to create a scatter plot of PHRED scaled quality (<code>QUAL</code>) over position (<code>POS</code>) with the samples showing in different colors. Make sure to give your plot relevant axis labels.</p>"},{"location":"06-data-visualization/#solution_1","title":"Solution","text":"<p><code>{r scatter-challenge-2, purl=FALSE}  ggplot(data = variants, aes(x = POS, y = QUAL, color = sample_id)) +   geom_point() +   labs(x = \"Base Pair Position\",        y = \"PHRED-sacled Quality (QUAL)\") +   facet_grid(sample_id ~ .)</code> {: .solution} {: .challenge}</p>"},{"location":"06-data-visualization/#barplots","title":"Barplots","text":"<p>We can create barplots using the <code>geom_bar</code> geom. Let's make a barplot showing the number of variants for each sample that are indels.</p> <p><code>{r barplot, purl=FALSE} ggplot(data = variants, aes(x = INDEL, fill = sample_id)) +   geom_bar() +   facet_grid(sample_id ~ .)</code></p>"},{"location":"06-data-visualization/#challenge_2","title":"Challenge","text":"<p>Since we already have the sample_id labels on the individual plot facets, we don't need the legend. Use the help file for <code>geom_bar</code> and any other online resources you want to use to remove the legend from the plot.</p>"},{"location":"06-data-visualization/#solution_2","title":"Solution","text":"<p><code>{r barplot-challenge, purl=FALSE} ggplot(data = variants, aes(x = INDEL, color = sample_id)) +    geom_bar(show.legend = F) +    facet_grid(sample_id ~ .)</code> {: .solution} {: .challenge}</p>"},{"location":"06-data-visualization/#density","title":"Density","text":"<p>We can create density plots using the <code>geom_density</code> geom that shows the distribution of of a variable in the dataset. Let's plot the distribution of <code>DP</code></p> <p><code>{r density, purl=FALSE} ggplot(data = variants, aes(x = DP)) +   geom_density()</code></p> <p>This plot tells us that the most of frequent <code>DP</code> (read depth) for the variants is about 10 reads.</p>"},{"location":"06-data-visualization/#challenge_3","title":"Challenge","text":"<p>Use <code>geom_density</code> to plot the distribution of <code>DP</code> with a different fill for each sample. Use a white background for the plot.</p>"},{"location":"06-data-visualization/#solution_3","title":"Solution","text":"<p><code>{r density-challenge, purl=FALSE} ggplot(data = variants, aes(x = DP, fill = sample_id)) +    geom_density(alpha = 0.5) +    theme_bw()</code> {: .solution} {: .challenge}</p>"},{"location":"06-data-visualization/#ggplot2-themes","title":"<code>ggplot2</code> themes","text":"<p>In addition to <code>theme_bw()</code>, which changes the plot background to white, <code>ggplot2</code> comes with several other themes which can be useful to quickly change the look of your visualization. The complete list of themes is available at https://ggplot2.tidyverse.org/reference/ggtheme.html. <code>theme_minimal()</code> and <code>theme_light()</code> are popular, and <code>theme_void()</code> can be useful as a starting point to create a new hand-crafted theme.</p> <p>The ggthemes package provides a wide variety of options (including Microsoft Excel, old and new). The <code>ggplot2</code> extensions website provides a list of packages that extend the capabilities of <code>ggplot2</code>, including additional themes.</p>"},{"location":"06-data-visualization/#challenge_4","title":"Challenge","text":"<p>With all of this information in hand, please take another five minutes to either improve one of the plots generated in this exercise or create a beautiful graph of your own. Use the RStudio <code>ggplot2</code> cheat sheet for inspiration. Here are some ideas:</p> <ul> <li>See if you can change the size or shape of the plotting symbol.</li> <li>Can you find a way to change the name of the legend? What about     its labels?</li> <li>Try using a different color palette (see the Cookbook for     R. {:     .challenge}</li> </ul>"},{"location":"06-data-visualization/#more-ggplot2-plots","title":"More <code>ggplot2</code> Plots","text":"<p><code>ggplot2</code> offers many more informative and beautiful plots (<code>geoms</code>) of interest for biologists (although not covered in this lesson) that are worth exploring, such as</p> <ul> <li><code>geom_tile()</code>,     for heatmaps,</li> <li><code>geom_jitter()</code>,     for strip charts, and</li> <li><code>geom_violin()</code>,     for violin plots</li> </ul>"},{"location":"06-data-visualization/#resources","title":"Resources","text":"<ul> <li>ggplot2: Elegant Graphics for Data     Analysis (online     version)</li> <li>The Grammar of Graphics (Statistics and     Computing)</li> <li>Data Visualization: A Practical     Introduction     (online version)</li> <li>The R Graph Gallery (the     book)</li> </ul>"},{"location":"07-knitr-markdown/","title":"Producing Reports With knitr","text":"<p>Info</p> <p>keypoints:</p> <ul> <li>Keep reporting and R software together in one document using R   Markdown.</li> <li>Control formatting using chunk options.</li> <li>\"<code>knitr</code> can convert R Markdown documents to PDF and other formats.\"</li> </ul> <p>objectives:</p> <ul> <li>Value of reproducible reports</li> <li>Basics of Markdown</li> <li>R code chunks</li> <li>Chunk options</li> <li>Inline R code</li> <li>Other output formats</li> </ul> <p>questions:</p> <ul> <li>How can I integrate analyses and reports?</li> </ul>"},{"location":"07-knitr-markdown/#data-analysis-reports","title":"Data analysis reports","text":"<p>Data analysts tend to write a lot of reports, describing their analyses and results, for their collaborators or to document their work for future reference.</p> <p>When I was first starting out, I'd write an R script with all of my work, and would just send an email to my collaborator, describing the results and attaching various graphs. In discussing the results, there would often be confusion about which graph was which.</p> <p>I moved to writing formal reports, with Word or LaTeX, but I'd have to spend a lot of time getting the figures to look right. Mostly, the concern is about page breaks.</p> <p>Everything is easier now that I create a web page (as an html file). It can be one long stream, so I can use tall figures that wouldn't ordinary fit on one page. Scrolling is your friend.</p>"},{"location":"07-knitr-markdown/#literate-programming","title":"Literate programming","text":"<p>Ideally, such analysis reports are reproducible documents: If an error is discovered, or if some additional subjects are added to the data, you can just re-compile the report and get the new or corrected results (versus having to reconstruct figures, paste them into a Word document, and further hand-edit various detailed results).</p> <p>The key tool for R is knitr, which allows you to create a document that is a mixture of text and some chunks of code. When the document is processed by knitr, chunks of R code will be executed, and graphs or other results inserted.</p> <p>This sort of idea has been called \"literate programming\".</p> <p>knitr allows you to mix basically any sort of text with any sort of code, but we recommend that you use R Markdown, which mixes Markdown with R. Markdown is a light-weight mark-up language for creating web pages.</p>"},{"location":"07-knitr-markdown/#creating-an-r-markdown-file","title":"Creating an R Markdown file","text":"<p>Within R Studio, click File \u2192 New File \u2192 R Markdown and you'll get a dialog box like this:</p> <p>[]{.image .placeholder original-image-src=\"../fig/New_R_Markdown.png\" original-image-title=\"\"}</p> <p>You can stick with the default (HTML output), but give it a title.</p>"},{"location":"07-knitr-markdown/#basic-components-of-r-markdown","title":"Basic components of R Markdown","text":"<p>The initial chunk of text contains instructions for R: you give the thing a title, author, and date, and tell it that you're going to want to produce html output (in other words, a web page).</p> <pre><code>---\ntitle: \"Initial R Markdown document\"\nauthor: \"Karl Broman\"\ndate: \"April 23, 2015\"\noutput: html_document\n---\n</code></pre> <p>You can delete any of those fields if you don't want them included. The double-quotes aren't strictly necessary in this case. They're mostly needed if you want to include a colon in the title.</p> <p>RStudio creates the document with some example text to get you started. Note below that there are chunks like</p> <p><pre><code>&lt;pre&gt;\n&amp;#96;&amp;#96;&amp;#96;{r}\nsummary(cars)\n&amp;#96;&amp;#96;&amp;#96;\n&lt;/pre&gt;\n</code></pre> These are chunks of R code that will be executed by knitr and replaced by their results. More on this later.</p> <p>Also note the web address that's put between angle brackets (<code>&lt; &gt;</code>) as well as the double-asterisks in <code>**Knit**</code>. This is Markdown.</p>"},{"location":"07-knitr-markdown/#markdown","title":"Markdown","text":"<p>Markdown is a system for writing web pages by marking up the text much as you would in an email rather than writing html code. The marked-up text gets converted to html, replacing the marks with the proper html code.</p> <p>For now, let's delete all of the stuff that's there and write a bit of markdown.</p> <p>You make things bold using two asterisks, like this: <code>**bold**</code>, and you make things italics by using underscores, like this: <code>_italics_</code>.</p> <p>You can make a bulleted list by writing a list with hyphens or asterisks, like this:</p> <pre><code>* bold with double-asterisks\n* italics with underscores\n* code-type font with backticks\n</code></pre> <p>or like this:</p> <pre><code>- bold with double-asterisks\n- italics with underscores\n- code-type font with backticks\n</code></pre> <p>Each will appear as:</p> <ul> <li>bold with double-asterisks</li> <li>italics with underscores</li> <li>code-type font with backticks</li> </ul> <p>(I prefer hyphens over asterisks, myself.)</p> <p>You can make a numbered list by just using numbers. You can use the same number over and over if you want:</p> <pre><code>1. bold with double-asterisks\n1. italics with underscores\n1. code-type font with backticks\n</code></pre> <p>This will appear as:</p> <ol> <li>bold with double-asterisks</li> <li>italics with underscores</li> <li>code-type font with backticks</li> </ol> <p>You can make section headers of different sizes by initiating a line with some number of <code>#</code> symbols:</p> <pre><code># Title\n## Main section\n### Sub-section\n#### Sub-sub section\n</code></pre> <p>You compile the R Markdown document to an html webpage by clicking the \"Knit HTML\" in the upper-left. And note the little question mark next to it; click the question mark and you'll get a \"Markdown Quick Reference\" (with the Markdown syntax) as well to the RStudio documentation on R Markdown.</p>"},{"location":"07-knitr-markdown/#challenge","title":"Challenge","text":"<p>Create a new R Markdown document. Delete all of the R code chunks and write a bit of Markdown (some sections, some italicized text, and an itemized list).</p> <p>Convert the document to a webpage. {: .challenge}</p>"},{"location":"07-knitr-markdown/#a-bit-more-markdown","title":"A bit more Markdown","text":"<p>You can make a hyperlink like this: <code>[text to show](http://the-web-page.com)</code>.</p> <p>You can include an image file like this: <code>![caption](http://url/for/file)</code></p> <p>You can do subscripts (e.g., F2) with <code>F~2</code> and superscripts (e.g., F2) with <code>F^2^</code>.</p> <p>If you know how to write equations in LaTeX, you'll be glad to know that you can use <code>$ $</code> and <code>$$ $$</code> to insert math equations, like <code>$E = mc^2$</code> and</p> <pre><code>$$y = \\mu + \\sum_{i=1}^p \\beta_i x_i + \\epsilon$$\n</code></pre>"},{"location":"07-knitr-markdown/#r-code-chunks","title":"R code chunks","text":"<p>Markdown is interesting and useful, but the real power comes from mixing markdown with chunks of R code. This is R Markdown. When processed, the R code will be executed; if they produce figures, the figures will be inserted in the final document.</p> <p>The main code chunks look like this:</p> <p><pre><code>&lt;pre&gt;\n&amp;#96;&amp;#96;&amp;#96;{r load_data}\ngapminder &lt;- read.csv(\"~/Desktop/gapminder.csv\")\n&amp;#96;&amp;#96;&amp;#96;\n&lt;/pre&gt;\n</code></pre> That is, you place a chunk of R code between <code>&lt;code&gt;</code>```{r chunk_name}<code>&lt;/code&gt;</code> and <code>&lt;code&gt;</code>```<code>&lt;/code&gt;</code>. It's a good idea to give each chunk a name, as they will help you to fix errors and, if any graphs are produced, the file names are based on the name of the code chunk that produced them.</p>"},{"location":"07-knitr-markdown/#challenge_1","title":"Challenge","text":"<p>Add code chunks to</p> <ul> <li>Load the ggplot2 package</li> <li>Read the gapminder data</li> <li>Create a plot {: .challenge}</li> </ul>"},{"location":"07-knitr-markdown/#how-things-get-compiled","title":"How things get compiled","text":"<p>When you press the \"Knit HTML\" button, the R Markdown document is processed by knitr and a plain Markdown document is produced (as well as, potentially, a set of figure files): the R code is executed and replaced by both the input and the output; if figures are produced, links to those figures are included.</p> <p>The Markdown and figure documents are then processed by the tool pandoc, which converts the Markdown file into an html file, with the figures embedded.</p> <p>```{r rmd_to_html_fig, fig.width=8, fig.height=3, fig.align=\"left\", echo = FALSE} par(mar=rep(0, 4), bty=\"n\", cex=1.5) plot(0, 0, type=\"n\", xlab=\"\", ylab=\"\", xaxt=\"n\", yaxt=\"n\", xlim=c(0, 100), ylim=c(0, 100)) xw \\&lt;- 10 yh \\&lt;- 35 xm \\&lt;- 12 ym \\&lt;- 50 rect(xm-xw/2, ym-yh/2, xm+xw/2, ym+yh/2, lwd=2) text(xm, ym, \".Rmd\")</p> <p>xm \\&lt;- 50 ym \\&lt;- 80 rect(xm-xw/2, ym-yh/2, xm+xw/2, ym+yh/2, lwd=2) text(xm, ym, \".md\") xm \\&lt;- 50; ym \\&lt;- 25 for(i in c(2, 0, -2)) rect(xm-xw/2+i, ym-yh/2+i, xm+xw/2+i, ym+yh/2+i, lwd=2, border=\"black\", col=\"white\") text(xm-2, ym-2, \"figs/\")</p> <p>xm \\&lt;- 100-12 ym \\&lt;- 50 rect(xm-xw/2, ym-yh/2, xm+xw/2, ym+yh/2, lwd=2) text(xm, ym, \".html\")</p> <p>arrows(22, 50, 38, 50, lwd=2, col=\"slateblue\", len=0.1) text((22+38)/2, 60, \"knitr\", col=\"darkslateblue\", cex=1.3)</p> <p>arrows(62, 50, 78, 50, lwd=2, col=\"slateblue\", len=0.1) text((62+78)/2, 60, \"pandoc\", col=\"darkslateblue\", cex=1.3) ```</p>"},{"location":"07-knitr-markdown/#chunk-options","title":"Chunk options","text":"<p>There are a variety of options to affect how the code chunks are treated.</p> <ul> <li>Use <code>echo = FALSE</code> to avoid having the code itself shown.</li> <li>Use <code>results = \"hide\"</code> to avoid having any results printed.</li> <li>Use <code>eval = FALSE</code> to have the code shown but not evaluated.</li> <li>Use <code>warning = FALSE</code> and <code>message = FALSE</code> to hide any warnings or     messages produced.</li> <li>Use <code>fig.height</code> and <code>fig.width</code> to control the size of the figures     produced (in inches).</li> </ul> <p>So you might write:</p> <p><pre><code>&lt;pre&gt;\n&amp;#96;&amp;#96;&amp;#96;{r load_libraries, echo=FALSE, message=FALSE}\nlibrary(\"dplyr\")\nlibrary(\"ggplot2\")\n&amp;#96;&amp;#96;&amp;#96;\n&lt;/pre&gt;\n</code></pre> Often there will be particular options that you'll want to use repeatedly; for this, you can set global chunk options, like so:</p> <p><pre><code>&lt;pre&gt;\n&amp;#96;&amp;#96;&amp;#96;{r global_options, echo=FALSE}\nknitr::opts_chunk$set(fig.path=\"Figs/\", message=FALSE, warning=FALSE,\n                      echo=FALSE, results=\"hide\", fig.width=11)\n&amp;#96;&amp;#96;&amp;#96;\n&lt;/pre&gt;\n</code></pre> The <code>fig.path</code> option defines where the figures will be saved. The <code>/</code> here is really important; without it, the figures would be saved in the standard place but just with names that being with <code>Figs</code>.</p> <p>If you have multiple R Markdown files in a common directory, you might want to use <code>fig.path</code> to define separate prefixes for the figure file names, like <code>fig.path=\"Figs/cleaning-\"</code> and <code>fig.path=\"Figs/analysis-\"</code>.</p>"},{"location":"07-knitr-markdown/#challenge_2","title":"Challenge","text":"<p>Use chunk options to control the size of a figure and to hide the code. {: .challenge}</p>"},{"location":"07-knitr-markdown/#inline-r-code","title":"Inline R code","text":"<p>You can make every number in your report reproducible. Use <code>&lt;code&gt;</code>`r<code>&lt;/code&gt;</code> and <code>&lt;code&gt;</code>`<code>&lt;/code&gt;</code> for an in-line code chunk, like so: <code>&lt;code&gt;</code>`r round(some_value, 2)`<code>&lt;/code&gt;</code>. The code will be executed and replaced with the value of the result.</p> <p>Don't let these in-line chunks get split across lines.</p> <p>Perhaps precede the paragraph with a larger code chunk that does calculations and defines things, with <code>include=FALSE</code> for that larger chunk (which is the same as <code>echo=FALSE</code> and <code>results=\"hide\"</code>).</p> <p>I'm very particular about rounding in such situations. I may want <code>2.0</code>, but <code>round(2.03, 1)</code> will give just <code>2</code>.</p> <p>The <code>myround</code> function in the broman package handles this.</p>"},{"location":"07-knitr-markdown/#challenge_3","title":"Challenge","text":"<p>Try out a bit of in-line R code. {: .challenge}</p>"},{"location":"07-knitr-markdown/#other-output-options","title":"Other output options","text":"<p>You can also convert R Markdown to a PDF or a Word document. Click the little triangle next to the \"Knit HTML\" button to get a drop-down menu. Or you could put <code>pdf_document</code> or <code>word_document</code> in the header of the file.</p>"},{"location":"07-knitr-markdown/#tip-creating-pdf-documents","title":"Tip: Creating PDF documents","text":"<p>Creating .pdf documents may require installation of some extra software. If required this is detailed in an error message.</p> <p>To install the required software to knit your report to a PDF, you can run the following code:</p> <pre><code>install.packages('tinytex')\ntinytex::install_tinytex()\n</code></pre> <p>{: .callout}</p>"},{"location":"07-knitr-markdown/#resources","title":"Resources","text":"<ul> <li>Knitr in a knutshell tutorial</li> <li>Dynamic Documents with R and     knitr     (book)</li> <li>R Markdown documentation</li> <li>R Markdown cheat     sheet     (PDF)</li> <li>Getting started with R     Markdown</li> <li>Reproducible     Reporting</li> <li>Introducing     Bookdown</li> </ul>"},{"location":"08-r-help/","title":"Getting help with R","text":"<p>Info</p> <p>keypoints:</p> <ul> <li>R provides thousands of functions for analyzing data, and provides   several way to get help</li> <li>Using R will mean searching for online help, and there are tips and   resources on how to search effectively</li> </ul> <p>objectives:</p> <ul> <li>Locate help for an R function using <code>?</code>, <code>??</code>, and <code>args()</code></li> <li>Check the version of R</li> <li>Be able to ask effective questions when searching for help on forums   or using web searches</li> </ul> <p>questions:</p> <ul> <li>How do I get help using R and RStudio?</li> </ul>"},{"location":"08-r-help/#getting-help-with-r_1","title":"Getting help with R","text":"<p><code>&lt;img src=\"../fig/oreilly_book_covers.png\" alt=\"rstudio default session\" style=\"width: 600px;\"/&gt;</code></p> <p>No matter how much experience you have with R, you will find yourself needing help. There is no shame in researching how to do something in R, and most people will find themselves looking up how to do the same things that they \"should know how to do\" over and over again. Here are some tips to make this process as helpful and efficient as possible.</p> <p>\"Never memorize something that you can look up\" -- A. Einstein</p>"},{"location":"08-r-help/#finding-help-on-stackoverflow-and-biostars","title":"Finding help on Stackoverflow and Biostars","text":"<p>Two popular websites will be of great help with many R problems. For general R questions, Stack Overflow is probably the most popular online community for developers. If you start your question \"How to do X in R\" results from Stack Overflow are usually near the top of the list. For bioinformatics specific questions, Biostars is a popular online forum.</p>"},{"location":"08-r-help/#tip-asking-for-help-using-online-forums","title":"Tip: Asking for help using online forums:","text":"<ul> <li>When searching for R help, look for answers with the     r tag.</li> <li>Get an account; not required to view answers but to required to     post</li> <li>Put in effort to check thoroughly before you post a question;     folks get annoyed if you ask a very common question that has been     answered multiple times</li> <li>Be careful. While forums are very helpful, you can't know for sure     if the advice you are getting is correct</li> <li>See the How to ask for R     help     blog post for more useful tips</li> </ul> <p>{: .callout}</p>"},{"location":"08-r-help/#help-people-help-you","title":"Help people help you","text":"<p>Often, in order to duplicate the issue you are having, someone may need to see the data you are working with or verify the versions of R or R packages you are using. The following R functions will help with this:</p> <p>You can check the version of R you are working with using the <code>sessionInfo()</code> function. Actually, it is good to save this information as part of your notes on any analysis you are doing. When you run the same script that has worked fine a dozen times before, looking back at these notes will remind you that you upgraded R and forget to check your script.</p> <pre><code>sessionInfo()\n</code></pre> <p>{: .language-r}</p> <pre><code>R version 3.2.3 (2015-12-10)\nPlatform: x86_64-pc-linux-gnu (64-bit)\nRunning under: Ubuntu 14.04.3 LTS\n\nlocale:\n[1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C               LC_TIME=en_US.UTF-8\n[4] LC_COLLATE=en_US.UTF-8     LC_MONETARY=en_US.UTF-8    LC_MESSAGES=en_US.UTF-8\n[7] LC_PAPER=en_US.UTF-8       LC_NAME=C                  LC_ADDRESS=C\n[10] LC_TELEPHONE=C             LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base\n\nloaded via a namespace (and not attached):\n[1] tools_3.2.3     packrat_0.4.9-1\n</code></pre> <p>{: .output}</p> <p>Many times, there may be some issues with your data and the way it is formatted. In that case, you may want to share that data with someone else. However, you may not need to share the whole dataset; looking at a subset of your 50,000 row, 10,000 column dataframe may be TMI (too much information)! You can take an object you have in memory such as dataframe (if you don't know what this means yet, we will get to it!) and save it to a file. In our example we will use the <code>dput()</code> function on the <code>iris</code> dataframe which is an example dataset that is installed in R:</p> <pre><code>dput(head(iris)) # iris is an example data.frame that comes with R\n                 # the `head()` function just takes the first 6 lines of the iris dataset\n</code></pre> <p>{: .language-r}</p> <p>This generates some output (below) which you will be better able to interpret after covering the other R lessons. This info would be helpful in understanding how the data is formatted and possibly revealing problematic issues.</p> <pre><code>structure(list(Sepal.Length = c(5.1, 4.9, 4.7, 4.6, 5, 5.4),\n    Sepal.Width = c(3.5, 3, 3.2, 3.1, 3.6, 3.9), Petal.Length = c(1.4,\n    1.4, 1.3, 1.5, 1.4, 1.7), Petal.Width = c(0.2, 0.2, 0.2,\n    0.2, 0.2, 0.4), Species = structure(c(1L, 1L, 1L, 1L, 1L,\n    1L), .Label = c(\"setosa\", \"versicolor\", \"virginica\"), class = \"factor\")), .Names = c(\"Sepal.Length\",\n\"Sepal.Width\", \"Petal.Length\", \"Petal.Width\", \"Species\"), row.names = c(NA,\n6L), class = \"data.frame\")\n</code></pre> <p>{: .output}</p> <p>Alternatively, you can also save objects in R memory to a file by specifying the name of the object, in this case the <code>iris</code> data frame, and passing a filename to the <code>file=</code> argument.</p> <p><code>{r, eval=FALSE} saveRDS(iris, file=\"iris.rds\") # By convention, we use the .rds file extension</code></p>"},{"location":"08-r-help/#final-faqs-on-r","title":"Final FAQs on R","text":"<p>Finally, here are a few pieces of introductory R knowledge that are too good to pass up. While we won't return to them in this course, we put them here because they come up commonly:</p> <p>Do I need to click Run every time I want to run a script?</p> <ul> <li> <p>No.\u00a0In fact, the most common shortcut key allows you to run a     command (or any lines of the script that are highlighted):</p> <ul> <li>Windows execution shortcut:     <code>&lt;KBD&gt;</code>Ctrl<code>&lt;/KBD&gt;</code>+<code>&lt;KBD&gt;</code>Enter<code>&lt;/KBD&gt;</code></li> <li>Mac execution shortcut:     <code>&lt;KBD&gt;</code>Cmd(\u2318)<code>&lt;/KBD&gt;</code>+<code>&lt;KBD&gt;</code>Enter<code>&lt;/KBD&gt;</code></li> </ul> <p>To see a complete list of shortcuts, click on the <code>&lt;KBD&gt;</code>Tools<code>&lt;/KBD&gt;</code> menu and select <code>&lt;KBD&gt;</code>Keyboard Shortcuts Help<code>&lt;/KBD&gt;</code></p> </li> </ul> <p>What's with the brackets in R console output? - R returns an index with your result. When your result contains multiple values, the number tells you what ordinal number begins the line, for example:</p> <pre><code>1:101 # generates the sequence of numbers from 1 to 101\n</code></pre> <p>In the output above, <code>[81]</code> indicates that the first value on that line is the 81st item in your result</p> <p>Can I run my R script without RStudio?</p> <ul> <li>Yes, remember - RStudio is running R. You get to use lots of the     enhancements RStudio provides, but R works independent of RStudio.     See these     tips     for running your commands at the command line</li> </ul> <p>Where else can I learn about RStudio? - Check out the <code>&lt;KBD&gt;</code>Help<code>&lt;/KBD&gt;</code> menu, especially \"Cheatsheets\" section</p>"}]}